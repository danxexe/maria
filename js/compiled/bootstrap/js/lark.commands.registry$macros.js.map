{"version":3,"sources":["lark/commands/registry$macros.cljc"],"mappings":"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","names":["lark.commands.registry$macros/parse-opt-args","preds","args","out","cljs.core/empty?","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","match?","G__71416","fexpr__71415","cljs.core/first","cljs.core/rest","G__71418","ret__4776__auto__","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","lark.commands.registry$macros/defcommand","&form","&env","seq71420","G__71421","cljs.core/next","G__71422","G__71423","self__4717__auto__","command-name","vec__71446","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","map__71450","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$3","cljs.core.get.cljs$core$IFn$_invoke$arity$2","cljs.core.sequence.cljs$core$IFn$_invoke$arity$1","cljs.core/seq","cljs.core.concat.cljs$core$IFn$_invoke$arity$variadic","cljs.core/List","docstring","options","arglist","body","cljs.core/string?","cljs.core/map?","cljs.core/vector?","bindings","when*","intercept-when*","_","js/Error","name-as-symbol","cljs.core.symbol.cljs$core$IFn$_invoke$arity$1","cljs.core/namespace","cljs.core/name","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","cljs.core/boolean?","cljs.core/vec","cljs.core.concat.cljs$core$IFn$_invoke$arity$0"],"sourcesContent":["(ns lark.commands.registry)\n\n(defn parse-opt-args [preds args]\n  (loop [preds preds\n         args args\n         out []]\n    (if (empty? preds)\n      (conj out args)\n      (let [match? ((first preds) (first args))]\n        (recur (rest preds)\n               (cond-> args match? (rest))\n               (conj out (if match? (first args) nil)))))))\n\n(defmacro defcommand\n  \"Defines a command. command-name should be a namespaced keyword, followed by the optional positional args:\n  - docstring\n  - options map, which may contain:\n      :bindings, a vector of keymaps to bind, each containing a keyset of the form 'Cmd-X'\n      :intercept-when, a predicate indicating whether the key binding should stopPropagation and preventDefault\n           (if not supplied, will stop the event when :exec-when is true)\n      :when, a predicate indicating whether the command is enabled for a given context\n  - a vector of arguments followed by body forms, for the command function.\n\n  If no arglist/body is provided, a passthrough function will be supplied, so that `defcommand`\n  can be used for documenting existing/built-in behaviour.\"\n  [command-name & args]\n  (let [[docstring options arglist body] (parse-opt-args [string? map? vector?] args)\n        {bindings        :bindings\n         when*           :when\n         intercept-when* :intercept-when\n         :or             {bindings []}} options\n        _ (when (nil? arglist)\n            (assert (empty? body)))\n        name-as-symbol (symbol (str (namespace command-name) \"_\" (name command-name)))\n        options (-> options\n                    (dissoc :intercept-when*\n                            :when*)\n                    (assoc :name command-name\n                           :doc docstring\n                           :exec-pred when*\n                           :intercept-pred (if (boolean? intercept-when*)\n                                             `(constantly ~intercept-when*)\n                                             intercept-when*)\n                           :command (if arglist\n                                      `(fn ~name-as-symbol ~arglist\n                                         ~@body)\n                                      `(fn ~name-as-symbol [] :lark.commands/Pass))))]\n    `(~'lark.commands.registry/register! ~options ~bindings)))"]}
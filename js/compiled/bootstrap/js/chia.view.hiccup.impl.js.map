{"version":3,"sources":["chia/view/hiccup/impl.cljs"],"mappings":";;;;;;;;AAQA;;;;AAAA,AAAMA,AAGHC;AAHH,AAIE,AAAMC,AAAM,AAAA,AAA4CD;AAClDE,AAAQ,AAAA,AAAMD;AADpB,AAEE,AAAa,AAAAE,AAAI,AAAA,AAAMF;AAAV,AAAA,AAAAE;AAAAA;;AAAA;;AACD,AAAA,AAAMF,AACD,AAAI,AAAYC,AACdA,AACA,AAAA,AAAA,AAACE,AAAY,AAAA,AAAMH;;AAE1C,AAAKI,AAAe,AAACC,AAAcP;AAEnC;;;;;;;AAAA,AAAMQ,AAMHC;AANH,AAOE,AAAM,AAAA,AAAYA;AAAlB;;AAAA,AACM,AAAA,AAAYA;AADlB;;AAAA,AAEM,AAAI,AAAA,AAACC,AAAiBD,AAClB,AAAA,AAACC,AAAiBD;AAAYA;;AAHxC,AAIY,AAACE,AAAAA,AAAAA,AAAaF,AAAAA;;;;;;AAE5B,AAAKG,AAAsB,AAACL,AAAcC;AAE1C;;;AAAA,AAAMK,AAEHC;AAFH,AAIO,AAACC,AAAU,AAAKC,AAAIC,AAAEC;AAAX,AACE,AAAAC,AAAUH;AA7BJ,AA6BN,AAAA,AAAAI,AAAA,AAAA,AAAA,AAAAD,AAAA,AAAAA;AAAA,AAAA,AAAAC,AAAA,AAAAC,AAAc,AAAAC,AAAc,AAACC,AAAKN;AAApB,AAAA,AAAAK,AAAAA,AAACX,AAAAA,AAAAA;AAAuBO;;AAAtCE;AAFbN,AACA;;AAGP,AAAA,AAAeU;AAEf,AAAA,AAAOC,AAAWC;AAAlB,AACE,AAAI,AAAA,AAAYA,AACZ,AAAA,AAAYA;;AAElB,AAAA,AAAOC,AAAU1B;AAAjB,AAAoB,AAAK,AAAYA;;AAErC,AAAA;;;;AAAA,AAAA2B,AAAME;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AAGFE;AAHJ,AAGW,AAAA,AAACC,AAAgBD;;;AAH5B,AAAA,AAAA,AAAMF,AAIFI,AAAWF;AAJf,AAgBQ,AAACjB,AACA,AAAKyB,AAASvB,AAAEC;AAAhB,AACE,AAAAuB,AAAiB,AAAA,AAAA,AAAU,AAACC,AAAmBzB,AAC5B,AAAA0B,AAAuB,AAACpB,AAAKN;AAA7B,AAAA,AAAA0B,AAAAA,AAAC/B,AAAAA,AAAAA;;AADpB,AAAA,AAAA,AAAA6B,AAAA;AAIED;;AAJF,AAAAC,AAAUf;AAAV,AAEE,AAAAkB,AAAiBJ;AAAjB,AAAA,AAAAI,AAAA,AAAAvB,AAA0BK,AACT,AAAAmB,AAAQ3B;AAAR,AAAA,AAAU,AAACO,AAAUC;AAAQ,AAAAmB,AAAChC;;AAA9BgC;;;;AADjBD;;AAfL,AAAAT,AAAQ,AAAA,AAAI,AAAA,AAAA,AAAOH,AAAOA,AAiBV;AAjBhBG,AAAA,AACQ,AAAA,AAAA,AAAOX,AAAc,AAAAY,AAAAD;AAAAE,AAAc,AAAOH;AAArB,AAAA,AAAAE,AAAAC,AAAAD,AAAAC,AAACb,AAAAA,AAAAA;AAD9BW;AAAAA,AAAA,AAAAA,AAGQ,AAACR,AAAS,AAAMO,AAChB,AAAAC,AAAA,AAACG,AAAU,AAAMJ;AAJzB,AAAA,AAMQ,AAACP,AAAS,AAAWO;AACrB,AAAAC,AAAA,AAACI,AAAc;AAAKtC;AAAL,AACE,AAAI,AAAA,AAAA,AAAOA;AACT,AAAA,AAAK,AAAWiC,AAAgBjC;;AAChC,AAAWiC;;;;;AAVtCC;;;;;AALR,AAAA,AAAA,AAAML;;AAAN","names":["chia.view.hiccup.impl/parse-key","x","match","classes","or__4131__auto__","clojure.string/replace","chia.view.hiccup.impl/parse-key-memo","chia.util/memoize-str","chia.view.hiccup.impl/name->react-attr","s","clojure.string/starts-with?","chia.util/camel-case","chia.view.hiccup.impl/name->react-attr-memo","chia.view.hiccup.impl/map->js","style","cljs.core/reduce-kv","obj","k","v","obj57140","obj57141","applied-science.js-interop.impl/wrap-key","G__57148","cljs.core/name","chia.view.hiccup.impl/*wrap-props*","chia.view.hiccup.impl/map-prop?","js-key","chia.view.hiccup.impl/defined?","var_args","G__57152","chia.view.hiccup.impl/props->js","js/Error","props","chia.view.hiccup.impl.props__GT_js.cljs$core$IFn$_invoke$arity$2","parsed-key","G__57160","G__57161","G__57162","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.update.cljs$core$IFn$_invoke$arity$3","js-props","temp__5722__auto__","cljs.core/qualified-keyword?","G__57154","obj57155","G__57156"],"sourcesContent":["(ns chia.view.hiccup.impl\n  (:require [clojure.string :as str]\n            [\"react\" :as react]\n            [applied-science.js-interop :as j]\n            [chia.util.perf :as perf]\n            [chia.util :as u]\n            [goog.object :as gobj]))\n\n(defn parse-key\n  \"Parses a hiccup key like :div#id.class1.class2 to return the tag name, id, and classes.\n   If tag-name is ommitted, defaults to 'div'. Class names are padded with spaces.\"\n  [x]\n  (let [match (.exec #\"([^#.]+)?(?:#([^.]+))?(?:\\.(.*))?\" x)\n        classes (aget match 3)]\n    (j/obj .-tag (or (aget match 1) \"div\")\n           .-id (aget match 2)\n           .-classes (if (undefined? classes)\n                       classes\n                       (str/replace (aget match 3) \".\" \" \")))))\n\n(def parse-key-memo (u/memoize-str parse-key))\n\n(defn name->react-attr\n  \"Return js (react) key for keyword/string.\n\n  - Namespaced keywords are ignored\n  - area- and data- prefixed keys are not camelCased\n  - other keywords are camelCased\"\n  [s]\n  (cond (identical? s \"for\") \"htmlFor\"\n        (identical? s \"class\") \"className\"\n        (or (str/starts-with? s \"data-\")\n            (str/starts-with? s \"aria-\")) s\n        :else (u/camel-case s)))\n\n(def name->react-attr-memo (u/memoize-str name->react-attr))\n\n(defn map->js\n  \"Return javascript object with camelCase keys (shallow)\"\n  [style]\n  (->> style\n       (reduce-kv (fn [obj k v]\n                    (j/assoc! obj (u/camel-case (name k)) v)) #js{})))\n\n(def ^:dynamic *wrap-props* nil)\n\n(defn- map-prop? [js-key]\n  (or (identical? js-key \"style\")\n      (identical? js-key \"dangerouslySetInnerHTML\")))\n\n(defn- defined? [x] (not (undefined? x)))\n\n(defn props->js\n  \"Returns a React-conformant javascript object. An alternative to clj->js,\n  allowing for key renaming without an extra loop through every prop map.\"\n  ([props] (props->js #js{} props))\n  ([parsed-key props]\n   (->> (cond-> (if (some? props) props {})\n                (some? *wrap-props*) (*wrap-props* (.-tag parsed-key))\n\n                (defined? (.-id parsed-key))\n                (assoc :id (.-id parsed-key))\n\n                (defined? (.-classes parsed-key))\n                (update :class (fn [x]\n                                 (if (some? x)\n                                   (str (.-classes parsed-key) \" \" x)\n                                   (.-classes parsed-key)))))\n        (reduce-kv\n         (fn [js-props k v]\n           (if-some [js-key (when-not (qualified-keyword? k)\n                              (name->react-attr-memo (name k)))]\n             (j/unchecked-set js-props js-key\n                              (cond-> v (map-prop? js-key) (map->js)))\n             js-props)) (js-obj)))))\n"]}
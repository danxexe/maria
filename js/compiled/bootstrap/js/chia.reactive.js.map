{"version":3,"sources":["chia/reactive.cljc"],"mappings":"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","names":["chia.reactive/*reader*","chia.reactive/*silent*","chia.reactive/*reader-dependency-log*","js/Error","chia.reactive/handle-next-deps!","reader","next-deps","prev-deps","cljs.core/deref","cljs.core.get.cljs$core$IFn$_invoke$arity$2","chia.reactive/dependencies","seq__61093","cljs.core/seq","chunk__61094","count__61095","i__61096","temp__5720__auto__","cljs.core/chunked-seq?","c__4550__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/first","cljs.core/next","source","cljs.core/set","cljs.core/keys","cljs.core.into.cljs$core$IFn$_invoke$arity$2","G__61108","G__61109","G__61110","G__61111","G__61113","G__61114","G__61115","G__61116","chia.reactive/transition!","x__4433__auto__","m__4434__auto__","chia.reactive/-invalidate!","goog/typeOf","m__4431__auto__","cljs.core/missing-protocol","chia.reactive/IInvalidate","var_args","G__61132","chia.reactive/invalidate!","chia.reactive.invalidate_BANG_.cljs$core$IFn$_invoke$arity$2","info","cljs.core/PROTOCOL_SENTINEL","cljs.core/native-satisfies?","chia.reactive/invalidate-readers!","seq__61142","chunk__61143","count__61144","i__61145","chia.reactive/dependents","chia.reactive.invalidate_BANG_.cljs$core$IFn$_invoke$arity$1","chia.reactive/on-transition","chia.reactive/ITransitionSimple","observed?","chia.reactive/on-transition-pattern","chia.reactive/ITransitionPattern","prev-patterns","next-patterns","js/chia","js/chia.reactive","js/chia.reactive.dependents","cljs.core/volatile!","js/chia.reactive.dependencies","chia.reactive/add-dependent","dependents","edge-data","cljs.core/assoc-in","chia.reactive/remove-dependent","cljs.core.update.cljs$core$IFn$_invoke$arity$4","cljs.core/dissoc","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","chia.reactive/add-dependency","dependencies","chia.reactive/remove-dependency","chia.reactive/add-dependent!","first-edge?","cljs.core/contains?","chia.reactive/remove-dependent!","chia.reactive/transition-simple!","prev","next","first-dep?","last-dep?","chia.reactive/transition-patterns!","cljs.core/empty?","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/Keyword","chia.reactive/dispose-reader!","seq__61187","chunk__61188","count__61189","i__61190","vec__61204","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","vec__61210","patterns"],"sourcesContent":["(ns chia.reactive\n  \"Central point where reactivity is coordinated\"\n  (:require [chia.util.macros :as m]\n            [applied-science.js-interop :as j])\n  #?(:cljs (:require-macros [chia.reactive :as r :refer [log-observation*]])))\n\n(declare transition! dependencies dependents)\n\n(def ^:dynamic *reader*\n  \"The reader being evaluated\"\n  nil)\n\n(def ^:dynamic *silent*\n  \"Flag to temporarily suspend reactivity\"\n  false)\n\n(def ^:dynamic *reader-dependency-log*\n  \"Keeps track of what data sources a reader accesses during compute\"\n  nil)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Reactive readers\n;;\n;; A reactive reader does two things:\n;;\n;; 1. Wraps its evaluation in the `with-dependency-tracking!` macro\n;;    (to handle dependency bookkeeping)\n;;\n;; 2. Implements `invalidate!`, to recompute when a dependency changes\n;;\n\n(defn handle-next-deps!\n  [reader next-deps]\n  {:pre [reader]}\n  (let [prev-deps (get @dependencies reader)]\n    (doseq [source (-> (set (keys next-deps))\n                       (into (keys prev-deps)))]\n      (transition! source reader\n                   (get prev-deps source)\n                   (get next-deps source)))))\n\n(m/defmacro with-dependency-tracking!\n  \"Evaluates `body`, creating dependencies for `reader` with arbitrary data sources.\"\n  [{:as   options\n    :keys [schedule\n           reader]\n    :or   {schedule '.call}} & body]\n  {:pre [(map? options)]}\n  `(let [reader# ~reader\n         result# (binding [*reader* reader#\n                           *reader-dependency-log* (volatile! {})]\n                   (let [value# (do ~@body)]\n                     (j/obj .-value value#\n                            .-deps @*reader-dependency-log*)))]\n     (~schedule #(handle-next-deps! reader# (.-deps result#)))\n     (.-value result#)))\n\n(defprotocol IInvalidate\n  (-invalidate! [reader]\n    \"We 'invalidate' a reader whenever one of its dependencies has changed.\n     Implementors should ensure that a call to `invalidate` will cause the\n     reader to re-evaluate.\"))\n\n(defn invalidate!\n  \"Invalidates `reader` (triggers re-evaluation)\"\n  ([reader] (invalidate! reader nil))\n  ([reader info]\n   (when-not *silent*\n     (if (satisfies? IInvalidate reader)\n       (-invalidate! reader)\n       ;; in the simplest case, a reader is simply a function.\n       (reader info)))))\n\n(defn invalidate-readers!\n  \"Invalidates all readers of `source`\"\n  [source]\n  (doseq [reader (keys (get @dependents source))]\n    (invalidate! reader))\n  source)\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Reactive data sources\n;;\n;; There are two kinds of sources:\n;; 1. simple sources, which only know if they are observed or not-observed,\n;; 2. pattern sources, which track per-reader 'patterns' to support dependency\n;;    on a subset of a source.\n\n;; A simple source:\n;; - calls `observe-simple!` when its value is dereferenced\n;; - implements `on-transition` to know when its `observed?` state changes\n;; - calls `invalidate-readers!` when its value changes\n\n(defprotocol ITransitionSimple\n  (on-transition [source observed?]\n    \"Called when `source` is added or removed from the reactive graph.\"))\n\n;; A pattern source:\n;; - calls `observe-pattern!` when its value is accessed\n;; - implements `on-transition-pattern` to know when each reader's patterns change,\n;;   maintains its own index of readers and patterns\n;; - when its value changes, calls `invalidate-reader!` for readers\n;;   whose patterns are associated with data that has changed\n\n(defprotocol ITransitionPattern\n  \"Protocol which enables a reactive data source to support pattern-based dependencies.\"\n  (on-transition-pattern [source reader prev-patterns next-patterns]\n    \"Called when a reader has evaluated, and `source` is in prev- or next-patterns.\n\n    `next-patterns` is the result of successive applications of `observe-pattern!` during a read.\n    `prev-patterns` is for comparison with the last read.\"))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Dependency graph, with edge data\n;;\n\n;; {<source> {<reader> <pattern>}}\n(defonce ^:private dependents (volatile! {}))\n\n;; {<reader> {<source> <pattern>}}\n(defonce ^:private dependencies (volatile! {}))\n\n(defn- add-dependent [dependents source reader edge-data]\n  (assoc-in dependents [source reader] edge-data))\n\n(defn- remove-dependent [dependents source reader]\n  (if (> (count (get dependents source)) 1)\n    (update dependents source dissoc reader)\n    (dissoc dependents source)))\n\n(defn- add-dependency [dependencies reader source edge-data]\n  (assoc-in dependencies [reader source] edge-data))\n\n(defn- remove-dependency [dependencies reader source]\n  (if (> (count (get dependencies reader)) 1)\n    (update dependencies reader dissoc source)\n    (dissoc dependencies reader)))\n\n(defn- add-dependent! [source reader edge-data]\n  (let [first-edge? (not (contains? @dependents source))]\n    (vswap! dependents add-dependent source reader edge-data)\n    (vswap! dependencies add-dependency reader source edge-data)\n    ;; returns true if this is the first edge from `source`\n    first-edge?))\n\n(defn- remove-dependent! [source reader]\n  (vswap! dependents remove-dependent source reader)\n  (vswap! dependencies remove-dependency reader source)\n  ;; returns true if this was the last edge from `source`\n  (not (contains? @dependents source)))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; Read functions\n;;\n\n(defn transition-simple! [source reader prev next]\n  (cond (nil? prev) (let [first-dep? (add-dependent! source reader ::simple)]\n                      (when (true? first-dep?) (on-transition source true)))\n        (nil? next) (let [last-dep? (remove-dependent! source reader)]\n                      (when (true? last-dep?) (on-transition source false)))))\n\n(defn transition-patterns! [source reader prev next]\n  (if (empty? next)\n    (remove-dependent! source reader)\n    (add-dependent! source reader next))\n  (on-transition-pattern source reader prev next))\n\n(defn transition!\n  \"Updates watch for a source<>reader combo. Handles effectful updating of `source`.\"\n  [source reader prev-patterns next-patterns]\n  (when (not= prev-patterns next-patterns)\n    (if (or (keyword? prev-patterns) (keyword? next-patterns))\n      (transition-simple! source reader prev-patterns next-patterns)\n      (transition-patterns! source reader prev-patterns next-patterns))))\n\n(defn dispose-reader!\n  \"Removes reader from reactive graph.\"\n  [reader]\n  (doseq [[source patterns] (get @dependencies reader)]\n    (transition! source reader patterns nil))\n  reader)\n\n(m/defmacro silently\n  [& body]\n  `(binding [*silent* true]\n     ~@body))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;\n;; For implementing data sources\n;;\n\n(m/defmacro ^:private log-observation* [source expr]\n  `(do (when (some? *reader*)\n         (vswap! *reader-dependency-log* assoc ~source ~expr))\n       ~source))\n\n(m/defmacro observe-simple!\n  \"Logs simple observation of `source`, which should implement `ITransitionSimple`\"\n  [source]\n  `(log-observation* ~source ::simple))\n\n(m/defmacro observe-pattern!\n  \"Logs observation of `source`, which should implement `ITransitionPattern`.\n   `f` will be called with result of previous call to `observe-pattern!` for `source`\"\n  [source f & args]\n  `(log-observation* ~source (~f (get @*reader-dependency-log* ~source) ~@args)))"]}
{"version":3,"sources":["lark/tree/parse.cljc"],"mappings":"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","names":["cljs.core/enable-console-print!","lark.tree.parse/read-to-char-boundary","reader","c","cljs.tools.reader.reader-types/read-char","p1__65547#","lark.tree.reader/read-until","lark.tree.reader/whitespace?","lark.tree.reader/boundary?","lark.tree.parse/dispatch","cljs.core/first","lark.tree.reader/*delimiter*","lark.tree.reader/non-breaking-space","lark.tree.reader/newline?","lark.tree.parse/printable-only?","n","or__4131__auto__","cljs.core/keyword-identical?","cljs.core.get.cljs$core$IFn$_invoke$arity$2","lark.tree.parse/take-printable-children","tag","lark.tree.reader/conj-children","lark.tree.reader/EmptyNode","lark.tree.parse/parse-next","cljs.core/complement","lark.tree.parse/macro-char?","ch","G__65574","lark.tree.parse/macro-terminating?","and__4120__auto__","lark.tree.parse/read-token*","rdr","initch","sb","js/goog.string.StringBuffer","cljs.tools.reader.reader-types/unread","G__65578","cljs.tools.reader.reader-types/peek-char","lark.tree.parse/parse-keyword","resolve-ns?","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","_","token","expr","e65579","cljs.tools.reader.edn.read_string.cljs$core$IFn$_invoke$arity$1","js/Error","e","lark.tree.reader/->Node","lark.tree.parse/parse-token","lark.tree.reader/ValueNode","G__65580","js/parseInt","js/isNaN","var_args","G__65583","lark.tree.parse/take-n-children","prefix","lark.tree.parse.take_n_children.cljs$core$IFn$_invoke$arity$5","first-printable-child-tag","vec__65584","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","vec__65587","line","col","lark.tree.reader/current-pos","offset","lark.tree.reader/current-offset","valid?","children","after","lark.tree.reader/take-children","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","G__65590","cljs.core/seq","lark.tree.reader.Splice.cljs$core$IFn$_invoke$arity$2","lark.tree.reader.InvalidToken_BANG_.cljs$core$IFn$_invoke$arity$3","cljs.core/count","cljs.core.into.cljs$core$IFn$_invoke$arity$2","lark.tree.parse/parse-sharp","G__65591","lark.tree.reader.InvalidToken_BANG_.cljs$core$IFn$_invoke$arity$2","lark.tree.parse.take_n_children.cljs$core$IFn$_invoke$arity$4","temp__5718__auto__","G__65592","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$variadic","lark.tree.parse/parse-unquote","lark.tree.parse/parse-next*","G__65599","cljs.core/Keyword","lark.tree.reader/ignore","x","fexpr__65603","lark.tree.reader/read-while","lark.tree.reader/space?","p1__65594#","lark.tree.reader/NodeWithChildren","lark.tree.emit/bracket-match","lark.tree.reader/read-string-data","lark.tree.reader/read-with-position","lark.tree.parse/indexing-reader","s","cljs.tools.reader.reader_types.indexing_push_back_reader.cljs$core$IFn$_invoke$arity$1","cljs.tools.reader.reader_types.string_push_back_reader.cljs$core$IFn$_invoke$arity$2","lark.tree.parse/ast","*invalid-nodes*-orig-val__65607","*invalid-nodes*-temp-val__65608","lark.tree.reader/*invalid-nodes*","cljs.core/volatile!","base","lark.tree.reader/assoc-range!","vec__65615","source","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__65618","p__65619","vec__65620","map__65623","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","values","node","end-offset","node-str","cljs.core.subs.cljs$core$IFn$_invoke$arity$3","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","cljs.core/deref","lark.tree.util/guard->","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","cljs.core/not","cljs.core/empty?"],"sourcesContent":[";; modified from https://github.com/rundis/rewrite-cljs\n;; https://github.com/rundis/rewrite-cljs/blob/master/LICENSE\n\n(ns lark.tree.parse\n  (:require [lark.tree.reader :as rd]\n            [lark.tree.emit :as emit]\n            [lark.tree.node :as n]\n            [clojure.string :as string]\n            [cljs.tools.reader.impl.commons :refer [parse-symbol]]\n            [lark.tree.util :as util]\n\n   #?@(:cljs\n       [[cljs.tools.reader.reader-types :as r]\n        [cljs.tools.reader.edn :as edn]])\n   #?@(:clj\n       [\n            [clojure.tools.reader.reader-types :as r]\n            [clojure.tools.reader.edn :as edn]\n            [lark.tree.util :as util :refer [contains-identical-keyword?]]])\n            [clojure.string :as str])\n  #?(:cljs (:require-macros [lark.tree.util :as util :refer [contains-identical-keyword? contains-identical?]]))\n  (:import goog.string.StringBuffer))\n\n#?(:cljs (enable-console-print!))\n\n(declare parse-next)\n\n(defn read-to-char-boundary\n  [reader]\n  (let [c (r/read-char reader)]\n    (str c\n         (if (identical? c \\\\)\n           \"\"\n           (rd/read-until\n            reader\n            #(or (rd/whitespace? %)\n                 (rd/boundary? %)))))))\n\n(defn dispatch\n  [c]\n  (cond\n    (nil? c) :eof\n    (identical? c (first rd/*delimiter*)) :matched-delimiter\n    (contains-identical? [\\}\n                          \\]\n                          \\)] c) :unmatched-delimiter\n\n\n    (identical? c \\,) :comma\n\n    (or (identical? c \\space)\n        (identical? c rd/non-breaking-space)\n        (identical? c \\tab)) :space\n\n    (rd/newline? c) :newline\n\n    (identical? c \\^) :meta\n    (identical? c \\#) :sharp\n    (identical? c \\() :list\n    (identical? c \\[) :vector\n    (identical? c \\{) :map\n    (identical? c \\~) :unquote\n    (identical? c \\') :quote\n    (identical? c \\`) :syntax-quote\n    (identical? c \\;) :comment\n    (identical? c \\@) :deref\n    (identical? c \\\") :string\n    (identical? c \\:) :keyword\n    :else :token))\n\n(defn printable-only? [n]\n  (when n\n    (or\n     (contains-identical-keyword? [:space :comma :newline :comment :comment-block]\n                                  (.-tag n))\n     (get (.-options n) :invalid?))))\n\n(defn take-printable-children\n  [reader tag n]\n  (rd/conj-children\n   (rd/EmptyNode tag)\n   reader\n   {:read-fn parse-next\n    :count-pred (complement printable-only?)\n    :take-n n}))\n\n;; -------------- from cljs.tools.reader.edn ------------------\n\n(defn- macro-char? [ch]\n  (case ch\n    (\\\" \\: \\; \\^ \\( \\) \\[ \\] \\{ \\} \\\\ \\#) true\n    nil))\n\n(defn- macro-terminating? [ch]\n  (and (not (identical? \\# ch))\n       (not (identical? \\' ch))\n       (not (identical? \\: ch))\n       (macro-char? ch)))\n\n(defn ^String read-token*\n  [rdr initch]\n  (loop [sb (StringBuffer.)\n         ch (do (r/unread rdr initch) initch)]\n    (if (or (rd/whitespace? ch)\n            (macro-terminating? ch)\n            (nil? ch))\n      (str sb)\n      (recur (doto sb (.append (r/read-char rdr))) (r/peek-char rdr)))))\n\n;; -------------------------------------------------------------\n\n(defn parse-keyword\n  [reader]\n  (let [ch (r/read-char reader)\n        resolve-ns? (= \\: (r/peek-char reader))\n        _ (when resolve-ns?\n            (r/read-char reader))\n        token (read-token* reader ch)\n        expr (try (edn/read-string token)\n                  (catch js/Error e\n                    ::error))]\n    (rd/->Node :keyword\n               (when resolve-ns?\n                 {:resolve-ns? resolve-ns?}) nil expr nil)\n    ;; TODO\n    ;; is it important to validate whether this is a valid keyword?\n    #_(if (= expr ::error)\n      (rd/InvalidToken! :keyword token)\n      (rd/->Node :keyword\n                 (when resolve-ns?\n                   {:resolve-ns? resolve-ns?}) nil expr nil))))\n\n(defn parse-token\n  \"Parse a single token.\"\n  [reader]\n  (let [ch (r/read-char reader)\n        token (if (identical? ch \\\\)\n                (str ch (read-to-char-boundary reader))\n                (read-token* reader ch))]\n    (rd/ValueNode :token token)\n    (if (some-> (first token)\n                (js/parseInt)\n                (js/isNaN))\n      (rd/ValueNode :token token)\n      (rd/ValueNode :number token))\n    ;; TODO\n    ;; is it important to detect invalid tokens?\n    #_(try (let [[tag value] (let [value (edn/read-string token)]\n                             (if (symbol? value) [:symbol value]\n                                                 [:token token]))]\n           (prn [tag value])\n           (rd/ValueNode tag value))\n         (catch js/Error e\n           (rd/report-invalid!\n            (rd/->Node :token\n                       {:info {:tag (or (some-> (re-find #\"symbol|number\" (ex-message e))\n                                                (keyword))\n                                        :token)}}\n                       nil\n                       token\n                       nil))))))\n\n(defn take-n-children\n  ([reader tag prefix n] (take-n-children reader tag prefix n nil))\n  ([reader tag prefix n first-printable-child-tag]\n   (let [[line col] (rd/current-pos reader)\n         offset (rd/current-offset reader)\n         [valid? children after] (rd/take-children reader {:read-fn parse-next\n                                                           :count-pred (complement printable-only?)\n                                                           :take-n n})]\n     (if (and valid? (or (nil? first-printable-child-tag)\n                         (-> (first (filter (complement printable-only?) children))\n                             (.-tag)\n                             (= first-printable-child-tag))))\n       (-> (rd/EmptyNode tag)\n           (assoc :children children)\n           (cond-> (seq after)\n                   (rd/Splice after)))\n       (rd/Splice\n        (rd/InvalidToken! tag prefix [line\n                                      (- col (count prefix))\n                                      line\n                                      col\n                                      (- offset (count prefix))\n                                      offset])\n        (into children after))))))\n\n#_(defn try-take-all-children [reader tag]\n    (let [[valid? children after :as result] (rd/take-children reader {:read-fn parse-next})]\n      (if valid?\n        (-> (rd/EmptyNode tag)\n            (assoc :children children)\n            (cond-> (seq after)\n                    (rd/Splice after)))\n        (into children after))))\n\n(defn parse-sharp\n  [reader]\n  (r/read-char reader)\n  (case (r/peek-char reader)\n    nil (rd/InvalidToken! :reader-macro \"#\")\n    \\{ (take-n-children reader :set \\# 1 :map)\n    \\( (take-n-children reader :fn \\# 1 :list)\n    \\\" (take-n-children reader :regex \\# 1 :string)\n    \\^ (do (r/read-char reader)\n           (take-n-children reader :reader-meta \"#^\" 2))\n    \\' (do (r/read-char reader)\n           (take-n-children reader :var \"#'\" 1 :token))\n    \\_ (do (r/read-char reader)\n           (take-n-children reader :uneval \"#_\" 1))\n    \\? (do\n         (r/read-char reader)\n         (let [ch (r/peek-char reader)]\n           (if-let [tag (case ch\n                          \\( :reader-conditional\n                          \\@ (do (r/read-char reader)\n                                 :reader-conditional-splice)\n                          nil)]\n             (take-n-children reader tag (str \"#?\" (when (= ch \\@ \\@))) 1 :list)\n             (rd/InvalidToken! :reader-macro \"#?\"))))\n    ;; TODO\n    ;; namespaced maps\n    (rd/InvalidToken! :reader-macro \"#\")\n    #_(take-printable-children reader :reader-macro 2)))\n\n(defn parse-unquote\n  [reader]\n  (r/read-char reader)\n  (let [c (r/peek-char reader)]\n    (if (identical? c \\@)\n      (do (r/read-char reader)\n          (take-printable-children reader :unquote-splicing 1))\n      (take-printable-children reader :unquote 1))))\n\n(defn parse-next*\n  [reader]\n  (let [c (r/peek-char reader)\n        tag (dispatch c)]\n    (case tag\n\n      :token (parse-token reader)\n\n      :keyword (parse-keyword reader)\n\n      :sharp (parse-sharp reader)\n\n      :comment (do (rd/ignore reader)\n                   (rd/ValueNode tag (rd/read-until reader\n                                                    (fn [x]\n                                                      (or (nil? x) (#{\\newline \\return} x))))))\n\n      (:deref\n       :quote\n       :syntax-quote) (do (r/read-char reader)\n                          (take-n-children reader tag c 1))\n\n      :unquote (parse-unquote reader)\n\n      :newline (do (rd/ignore reader)\n                   (rd/ValueNode tag (str \"\\n\" (rd/read-while reader rd/space?))))\n\n      :comma (rd/ValueNode tag (rd/read-while reader #(identical? % c)))\n\n      :space (rd/ValueNode tag (rd/read-while reader rd/space?))\n\n      (:list\n       :vector\n       :map) (rd/NodeWithChildren reader parse-next tag (get emit/bracket-match c))\n\n      :matched-delimiter (rd/ValueNode tag (r/read-char reader))\n\n      :unmatched-delimiter (-> (rd/ValueNode tag (r/read-char reader))\n                               (assoc :info {:direction :backward\n                                             :expects (get emit/bracket-match c)}))\n\n      :eof nil\n\n      :meta (do (r/read-char reader)\n                (take-printable-children reader tag 2))\n\n      :string (rd/read-string-data (rd/EmptyNode tag) reader))))\n\n(defn parse-next\n  [reader]\n  (rd/read-with-position reader parse-next*))\n\n(defn indexing-reader\n  \"Create reader for strings.\"\n  [s]\n  (r/indexing-push-back-reader\n   (r/string-push-back-reader s 10)))\n\n(defn ast\n  [s]\n  (binding [rd/*invalid-nodes* (volatile! [])]\n    (let [reader (indexing-reader s)]\n\n      (as-> (rd/->Node :base nil nil nil nil) base\n            (rd/conj-children base reader {:read-fn parse-next})\n            (rd/assoc-range! base [0 0\n                                   (.-line reader)\n                                   (.-column reader)\n                                   0 (.-length s)])\n            (let [[source children] (reduce (fn [[source values] {:as node\n                                                                  :keys [offset end-offset]}]\n                                              (let [node-str (subs s offset end-offset)]\n                                                [(str source node-str)\n                                                 (conj values (assoc node :source node-str))]))\n                                            [\"\" []] (get base :children))\n                  base (assoc base\n                         :source source\n                         :children children\n                         :invalid-nodes (util/guard-> @rd/*invalid-nodes*\n                                                      (comp not empty?)))]\n              base)))))\n"]}
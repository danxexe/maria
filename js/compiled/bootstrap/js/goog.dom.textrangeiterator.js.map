{
"version":3,
"file":"goog.dom.textrangeiterator.js",
"lineCount":153,
"mappings":"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",
"sources":["goog/dom/textrangeiterator.js"],
"sourcesContent":["// Copyright 2007 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Iterator between two DOM text range positions.\n *\n * @author robbyw@google.com (Robby Walker)\n */\n\ngoog.provide('goog.dom.TextRangeIterator');\n\ngoog.require('goog.array');\ngoog.require('goog.dom');\ngoog.require('goog.dom.NodeType');\ngoog.require('goog.dom.RangeIterator');\ngoog.require('goog.dom.TagName');\ngoog.require('goog.iter.StopIteration');\n\n\n\n/**\n * Subclass of goog.dom.TagIterator that iterates over a DOM range.  It\n * adds functions to determine the portion of each text node that is selected.\n *\n * @param {Node} startNode The starting node position.\n * @param {number} startOffset The offset in to startNode.  If startNode is\n *     an element, indicates an offset in to childNodes.  If startNode is a\n *     text node, indicates an offset in to nodeValue.\n * @param {Node} endNode The ending node position.\n * @param {number} endOffset The offset in to endNode.  If endNode is\n *     an element, indicates an offset in to childNodes.  If endNode is a\n *     text node, indicates an offset in to nodeValue.\n * @param {boolean=} opt_reverse Whether to traverse nodes in reverse.\n * @constructor\n * @extends {goog.dom.RangeIterator}\n * @final\n */\ngoog.dom.TextRangeIterator = function(\n    startNode, startOffset, endNode, endOffset, opt_reverse) {\n  /**\n   * The first node in the selection.\n   * @private {?Node}\n   */\n  this.startNode_ = null;\n\n  /**\n   * The last node in the selection.\n   * @private {?Node}\n   */\n  this.endNode_ = null;\n\n  /**\n   * The offset within the first node in the selection.\n   * @private {number}\n   */\n  this.startOffset_ = 0;\n\n  /**\n   * The offset within the last node in the selection.\n   * @private {number}\n   */\n  this.endOffset_ = 0;\n\n  /**\n   * Whether the node iterator is moving in reverse.\n   * @private {boolean}\n   */\n  this.isReversed_ = !!opt_reverse;\n\n  var goNext;\n\n  if (startNode) {\n    this.startNode_ = startNode;\n    this.startOffset_ = startOffset;\n    this.endNode_ = endNode;\n    this.endOffset_ = endOffset;\n\n    // Skip to the offset nodes - being careful to special case BRs since these\n    // have no children but still can appear as the startContainer of a range.\n    if (startNode.nodeType == goog.dom.NodeType.ELEMENT &&\n        /** @type {!Element} */ (startNode).tagName != goog.dom.TagName.BR) {\n      var startChildren = startNode.childNodes;\n      var candidate = startChildren[startOffset];\n      if (candidate) {\n        this.startNode_ = candidate;\n        this.startOffset_ = 0;\n      } else {\n        if (startChildren.length) {\n          this.startNode_ =\n              /** @type {Node} */ (goog.array.peek(startChildren));\n        }\n        goNext = true;\n      }\n    }\n\n    if (endNode.nodeType == goog.dom.NodeType.ELEMENT) {\n      this.endNode_ = endNode.childNodes[endOffset];\n      if (this.endNode_) {\n        this.endOffset_ = 0;\n      } else {\n        // The offset was past the last element.\n        this.endNode_ = endNode;\n      }\n    }\n  }\n\n  goog.dom.TextRangeIterator.base(\n      this, 'constructor', this.isReversed_ ? this.endNode_ : this.startNode_,\n      this.isReversed_);\n\n  if (goNext) {\n    try {\n      this.next();\n    } catch (e) {\n      if (e != goog.iter.StopIteration) {\n        throw e;\n      }\n    }\n  }\n};\ngoog.inherits(goog.dom.TextRangeIterator, goog.dom.RangeIterator);\n\n\n/** @override */\ngoog.dom.TextRangeIterator.prototype.getStartTextOffset = function() {\n  // Offsets only apply to text nodes.  If our current node is the start node,\n  // return the saved offset.  Otherwise, return 0.\n  return this.node.nodeType != goog.dom.NodeType.TEXT ?\n      -1 :\n      this.node == this.startNode_ ? this.startOffset_ : 0;\n};\n\n\n/** @override */\ngoog.dom.TextRangeIterator.prototype.getEndTextOffset = function() {\n  // Offsets only apply to text nodes.  If our current node is the end node,\n  // return the saved offset.  Otherwise, return the length of the node.\n  return this.node.nodeType != goog.dom.NodeType.TEXT ?\n      -1 :\n      this.node == this.endNode_ ? this.endOffset_ : this.node.nodeValue.length;\n};\n\n\n/** @override */\ngoog.dom.TextRangeIterator.prototype.getStartNode = function() {\n  return this.startNode_;\n};\n\n\n/**\n * Change the start node of the iterator.\n * @param {Node} node The new start node.\n */\ngoog.dom.TextRangeIterator.prototype.setStartNode = function(node) {\n  if (!this.isStarted()) {\n    this.setPosition(node);\n  }\n\n  this.startNode_ = node;\n  this.startOffset_ = 0;\n};\n\n\n/** @override */\ngoog.dom.TextRangeIterator.prototype.getEndNode = function() {\n  return this.endNode_;\n};\n\n\n/**\n * Change the end node of the iterator.\n * @param {Node} node The new end node.\n */\ngoog.dom.TextRangeIterator.prototype.setEndNode = function(node) {\n  this.endNode_ = node;\n  this.endOffset_ = 0;\n};\n\n/** @override */\ngoog.dom.TextRangeIterator.prototype.isLast = function() {\n  return this.isStarted() && this.isLastTag_();\n};\n\n/**\n * Returns true if the iterator is on the last step before StopIteration is\n * thrown, otherwise false.\n * @return {boolean}\n * @private\n */\ngoog.dom.TextRangeIterator.prototype.isLastTag_ = function() {\n  if (this.node != this.lastNode_()) {\n    return false;\n  }\n  // For a reverse iterator, this function will return true if the end offset is\n  // > 0 and the iterator is not currently on an end tag OR the end offset = 0\n  // and the iterator is currently on a start tag.\n  if (this.isReversed_) {\n    return this.startOffset_ ? !this.isEndTag() : this.isStartTag();\n  }\n  // For a forward-iterating iterator, this function will return true if the end\n  // offset is 0 or the iterator is not currently on a start tag.\n  return !this.endOffset_ || !this.isStartTag();\n};\n\n/**\n * Move to the next position in the selection.\n * Throws `goog.iter.StopIteration` when it passes the end of the range.\n * @return {Node} The node at the next position.\n * @override\n */\ngoog.dom.TextRangeIterator.prototype.next = function() {\n  if (this.isLast()) {\n    throw goog.iter.StopIteration;\n  }\n\n  // Call the super function.\n  return goog.dom.TextRangeIterator.superClass_.next.call(this);\n};\n\n/**\n * Get the last node the iterator will hit.\n * @return {?Node} The last node the iterator will hit.\n * @private\n */\ngoog.dom.TextRangeIterator.prototype.lastNode_ = function() {\n  return this.isReversed_ ? this.startNode_ : this.endNode_;\n};\n\n/** @override */\ngoog.dom.TextRangeIterator.prototype.skipTag = function() {\n  goog.dom.TextRangeIterator.superClass_.skipTag.apply(this);\n\n  // If the node we are skipping contains the end node, we just skipped past\n  // the end, so we stop the iteration.\n  if (goog.dom.contains(this.node, this.lastNode_())) {\n    throw goog.iter.StopIteration;\n  }\n};\n\n\n/**\n * @override\n * @suppress {strictMissingProperties} Part of the go/strict_warnings_migration\n */\ngoog.dom.TextRangeIterator.prototype.copyFrom = function(other) {\n  this.startNode_ = other.startNode_;\n  this.endNode_ = other.endNode_;\n  this.startOffset_ = other.startOffset_;\n  this.endOffset_ = other.endOffset_;\n  this.isReversed_ = other.isReversed_;\n\n  goog.dom.TextRangeIterator.superClass_.copyFrom.call(this, other);\n};\n\n\n/**\n * @return {!goog.dom.TextRangeIterator} An identical iterator.\n * @override\n */\ngoog.dom.TextRangeIterator.prototype.clone = function() {\n  var copy = new goog.dom.TextRangeIterator(\n      this.startNode_, this.startOffset_, this.endNode_, this.endOffset_,\n      this.isReversed_);\n  copy.copyFrom(this);\n  return copy;\n};\n"],
"names":["goog","provide","require","dom","TextRangeIterator","goog.dom.TextRangeIterator","startNode","startOffset","endNode","endOffset","opt_reverse","startNode_","endNode_","startOffset_","endOffset_","isReversed_","goNext","nodeType","NodeType","ELEMENT","tagName","TagName","BR","startChildren","childNodes","candidate","length","array","peek","base","next","e","iter","StopIteration","inherits","RangeIterator","prototype","getStartTextOffset","goog.dom.TextRangeIterator.prototype.getStartTextOffset","node","TEXT","getEndTextOffset","goog.dom.TextRangeIterator.prototype.getEndTextOffset","nodeValue","getStartNode","goog.dom.TextRangeIterator.prototype.getStartNode","setStartNode","goog.dom.TextRangeIterator.prototype.setStartNode","isStarted","setPosition","getEndNode","goog.dom.TextRangeIterator.prototype.getEndNode","setEndNode","goog.dom.TextRangeIterator.prototype.setEndNode","isLast","goog.dom.TextRangeIterator.prototype.isLast","isLastTag_","goog.dom.TextRangeIterator.prototype.isLastTag_","lastNode_","isEndTag","isStartTag","goog.dom.TextRangeIterator.prototype.next","superClass_","call","goog.dom.TextRangeIterator.prototype.lastNode_","skipTag","goog.dom.TextRangeIterator.prototype.skipTag","apply","contains","copyFrom","goog.dom.TextRangeIterator.prototype.copyFrom","other","clone","goog.dom.TextRangeIterator.prototype.clone","copy"]
}

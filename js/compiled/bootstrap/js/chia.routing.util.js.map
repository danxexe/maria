{"version":3,"sources":["chia/routing/util.cljc"],"mappings":";;;;AAMA,AAAA,AAAMA,AAAUC;AAAhB,AACE,AAAM,AAAAC,AAAKD;AAAL,AAAA,AAAAC;AACK,AAAA,AAACC,AAAQF;;AADdC;;;AAAN,AAEED;;AAFF;;;AAIF;;;AAAA,AAAMG,AAEHC,AAAOJ;AAFV,AAGE,AAAAK,AAASL;AAAT,AAAA,AACS,AAAK,AAACM,AAAiBN,AAAEI;AAAS,AAAAC,AAAKD;;AADhDC;;;AAGF;;;AAAA,AAAME,AAEHC,AAAGR;AAFN,AAGE,AAAAS,AAAQT;AAAR,AAAA,AACQ,AAACU,AAAEF,AAAG,AAACG,AAAMX;AAAI,AAAAS,AAAA,AAACG;;AAD1BH;;;AAGF,AAAA,AAAAI,AAAMG,AACUhB;AADhB,AAAA,AAAAc,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AACIG;AADJ,AAAAF,AAAAD,AAAA,AAAA,AACSI;AADT,AAEE,AAAKD,AAAKjB,AAAEkB;;AAEd;;;AAAA,AAAMC,AAEHC;AAFH,AAGE,AAACC,AAAU,AAAKD,AAAEE,AAAEC;AAAT,AACE,AAAAC,AAAQJ;AAAR,AAAA,AACQ,AAAI,AAAA,AAAMG,AACN,AAAA,AAACb,AAAKa;AAAI,AAAAC,AAACC,AAAOH;;AAF9BE;;AAEmCJ,AAAEA;;AAOpD;;;AAAA,AAAMM,AAEHN;AAFH,AAIK,AAAA,AAAI,AAAaO,AACE,AAACC,AAAQR;;AAKjC;;;AAAA,AAAMS,AAEH7B;AAFH,AAGW,AAAM8B,AAAI,AAAAH,AAAM,AAAA,AAACxB,AAAwBH;AACnC+B,AAAK,AAAeD;AAD1B,AAGO,AAACE,AAAO;AAAKZ,AAAEE;AAAP,AACE,AAAAW,AAAQb;AAAR,AAAA,AACQ,AAACrB,AAASuB;AAAG,AAAAW,AAACC,AAAM,AAACC,AAAQb,AAAG,AAAMS,AAAKT;;AADnDW;;;AAFV,AAAUF,AACV","names":["chia.routing.util/some-str","s","and__4120__auto__","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","chia.routing.util/ensure-leading-char","prefix","G__66650","clojure.string/starts-with?","chia.routing.util/trim-leading-char","ch","G__66656","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/first","cljs.core.subs.cljs$core$IFn$_invoke$arity$2","p__66664","vec__66665","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","chia.routing.util/wrap","left","right","chia.routing.util/remove-empty","m","cljs.core/reduce-kv","k","v","G__66673","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2","chia.routing.util/form-encode","js/goog.Uri","cljs.core/clj->js","chia.routing.util/form-decode","uri","data","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","G__66679","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","cljs.core.keyword.cljs$core$IFn$_invoke$arity$1"],"sourcesContent":["(ns chia.routing.util\n  (:require [clojure.string :as str]\n   #?(:clj\n            [ring.util.codec :as ring-codec]))\n  #?(:cljs (:import [goog Uri])))\n\n(defn some-str [s]\n  (when (and s\n             (not= \"\" s))\n    s))\n\n(defn ensure-leading-char\n  \"Ensure that string `s` begins with `prefix`\"\n  [prefix s]\n  (cond->> s\n           (not (str/starts-with? s prefix)) (str prefix)))\n\n(defn trim-leading-char\n  \"Remove leading occurrence of `ch`\"\n  [ch s]\n  (cond-> s\n          (= ch (first s)) (subs 1)))\n\n(defn wrap\n  [[left right] s]\n  (str left s right))\n\n(defn remove-empty\n  \"Remove empty values/strings from map\"\n  [m]\n  (reduce-kv (fn [m k v]\n               (cond-> m\n                       (or (nil? v)\n                           (= \"\" v)) (dissoc k))) m m))\n\n\n;; TODO\n;; when lambdaisland.uri releases its `normalize` branch, we can probably\n;; get rid of these implementations, & not use ring-codec / Uri at all\n\n(defn form-encode\n  \"Returns value as www-form-urlencoded string\"\n  [m]\n  #?(:cljs\n     (.. (.-QueryData Uri)\n         (createFromMap (clj->js m))\n         (toString))\n     :clj\n     (ring-codec/form-encode m)))\n\n(defn form-decode\n  \"Returns map of decoded www-form-urlencoded data\"\n  [s]\n  #?(:cljs (let [uri (Uri. (ensure-leading-char \"?\" s))\n                 data (.getQueryData uri)]\n             (->> (.getKeys data)\n                  (reduce (fn [m k]\n                            (cond-> m\n                                    (some-str k) (assoc (keyword k) (.get data k)))) {})))\n     :clj  (->> s\n                (ring-codec/form-decode)\n                (reduce-kv (fn [m k v]\n                             (cond-> m\n                                     (some-str k) (assoc (keyword k) v))) {}))))"]}
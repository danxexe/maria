{"version":3,"sources":["lark/tree/emit.cljc"],"mappings":"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","names":["lark.tree.emit/*ns*","cljs.core.symbol.cljs$core$IFn$_invoke$arity$1","lark.tree.emit/*features*","lark.tree.emit/*print-selections*","lark.tree.emit/edges","lark.tree.reader/edges","lark.tree.emit/bracket-match","lark.tree.emit/tag-for-print-only?","lark.tree.emit/wrap-children","start-indent","loc","children","vec__65432","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","tag","left","right","cljs.core.get.cljs$core$IFn$_invoke$arity$2","lark.tree.format/*pretty*","left-edge-width","or__4131__auto__","G__65438","body-indent","lark.tree.format.body_indent_STAR_.cljs$core$IFn$_invoke$arity$3","topline-indent","out","js/goog.string.StringBuffer","current-indent","remaining","cljs.core/empty?","G__65448","child","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","cljs.core/keyword-identical?","lark.tree.format/spaces","cljs.core.subvec.cljs$core$IFn$_invoke$arity$2","child-str","lark.tree.emit/string","child-multiline?","G__65449","clojure.string/includes?","G__65450","last-line","cljs.core/re-find","G__65451","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/str","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","var_args","G__65458","js/Error","indent","node","lark.tree.nav/child-locs","value","options","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","G__65461","G__65463","lark.tree.reader/*active-cursor-node*","lark.tree.format/emit-space?","clojure.string.join.cljs$core$IFn$_invoke$arity$1","cljs.core.sequence.cljs$core$IFn$_invoke$arity$2","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","p1__65454#","cljs.core.map.cljs$core$IFn$_invoke$arity$1","cljs.core.interpose.cljs$core$IFn$_invoke$arity$1","clojure.string/split-lines","G__65476","cljs.core/namespace","cljs.core/name","lark.tree.emit.string.cljs$core$IFn$_invoke$arity$2","G__65480","and__4120__auto__","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/type","fast-zip.core/ZipperLocation","lark.tree.node/ast-zip","lark.tree.emit/splice?","lark.tree.emit/as-code","forms","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","p__65481","map__65482","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","item","lark.tree.emit/sexp","fexpr__65487","cljs.core/contains?","cljs.core/into","cljs.core/conj","p__65489","map__65491","G__65494","cljs.core/Keyword","G__65499","cljs.core/seq","cljs.core/list","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","cljs.core/first","e65501","cljs.tools.reader.edn.read_string.cljs$core$IFn$_invoke$arity$1","e","cljs.core/vec","lark.tree.fn/fn-walk","cljs.core/set","cljs.core.concat.cljs$core$IFn$_invoke$arity$1","cljs.tools.reader.read_string.cljs$core$IFn$_invoke$arity$1","lark.tree.emit.string.cljs$core$IFn$_invoke$arity$1","vec__65507","feature","form","p1__65488#","cljs.core.remove.cljs$core$IFn$_invoke$arity$2","G__65516","cljs.core.partition.cljs$core$IFn$_invoke$arity$2","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","p__65510","vec__65511","map__65514","_","vec__65518","m","data","G__65522","cljs.core/native-satisfies?","cljs.core/IWithMeta","cljs.core/with-meta","cljs.core/map?","cljs.core/re-pattern","resolved-ns","temp__5718__auto__","the-ns","cljs.core.get.cljs$core$IFn$_invoke$arity$3","cljs.tools.reader/*alias-map*","cljs.core.keyword.cljs$core$IFn$_invoke$arity$2"],"sourcesContent":["(ns lark.tree.emit\n  (:refer-clojure :exclude [*ns*])\n  (:require [fast-zip.core :as z]\n            [lark.tree.fn :refer [fn-walk]]\n            [clojure.string :as string]\n            [lark.tree.format :as format]\n            [lark.tree.reader :as rd]\n            [lark.tree.node :as n]\n            [lark.tree.nav :as nav]\n            [lark.tree.util :as util]\n   #?@(:cljs [[cljs.tools.reader.edn :as edn]\n              [cljs.tools.reader :as r]])\n   #?@(:clj\n       [\n            [clojure.tools.reader.edn :as edn]\n            [clojure.tools.reader :as r]\n            [lark.tree.util :as util]\n            [lark.backtick.core :refer [template]]])\n            [clojure.string :as str])\n  (:import [goog.string StringBuffer])\n  #?(:cljs (:require-macros [lark.backtick.core :refer [template]]\n            [lark.tree.util :as util])))\n\n(def ^:dynamic *ns* (symbol \"lark.tree.user\"))\n(def ^:dynamic *features* #{:cljs})\n(def ^:dynamic *print-selections* false)\n\n(def edges rd/edges)\n\n(def bracket-match\n  {\\( \\)\n   \\{ \\}\n   \\[ \\]\n   \\) \\(\n   \\} \\{\n   \\] \\[})\n\n(def tag-for-print-only? #{:comment :comment-block :uneval :space :newline :comma})\n\n(declare string)\n\n(defn wrap-children [start-indent loc children]\n  (let [tag (.. loc -node -tag)\n        [left right] (get rd/edges tag)]\n    (if format/*pretty*\n      (let [left-edge-width (or (some-> left .-length) 0)\n            body-indent (+ left-edge-width (format/body-indent* start-indent loc 0))\n            topline-indent (+ left-edge-width start-indent)]\n        (loop [out (if left (StringBuffer. left)\n                            (StringBuffer. left))\n               current-indent topline-indent\n               remaining children]\n          (if (empty? remaining)\n            (.toString (cond-> out\n                               right (.append right)))\n            (let [child (nth remaining 0)\n                  tag (.. child -node -tag)]\n              (if (keyword-identical? tag :newline)\n                (recur\n                 (.append out \\newline (format/spaces body-indent))\n                 body-indent\n                 (subvec remaining 1))\n                (let [child-str (string current-indent child)\n                      child-multiline? (some-> child-str\n                                               (str/includes? \\newline))]\n                  (recur\n                   (cond-> out\n                           child-str (.append child-str))\n                   (if child-multiline?\n                     (let [last-line (re-find #\"\\n.*?$\" child-str)]\n                       (dec (.-length last-line)))\n                     (+ current-indent (some-> child-str .-length)))\n                   (subvec remaining 1))))))))\n      (str left (apply str (mapv (partial string start-indent) children)) right))))\n\n#_(defn children? [{:keys [tag]}]\n    (#{:list :fn :map :meta :set :vector :uneval} tag))\n(defn string\n  \"Emit ClojureScript string from a magic-tree AST\"\n  ([indent loc]\n   (when (some? loc)\n     (let [node (.-node loc)\n           children (nav/child-locs loc)\n           tag (.-tag node)\n           value (.-value node)\n           options (.-options node)]\n       (if (= :error tag)\n         nil\n         (case tag\n           :unmatched-delimiter value\n\n           :base (wrap-children 0 loc children)\n\n           :token value\n\n           (:symbol\n            :number) value\n\n           :comma value\n           :space (if format/*pretty*\n                    (cond\n                      (some-> rd/*active-cursor-node*\n                              (= node)) value #_(format/spaces (min 2 (.-length value))) ;;value\n                      (format/emit-space? loc) \" \")\n                    value)\n           :newline (if format/*pretty*\n                      (str \\newline (format/spaces indent))\n                      value)\n\n           :selection (when (some? *print-selections*)\n                        (wrap-children indent loc children))\n\n           :cursor (when (some? *print-selections*) \"|\")\n\n           (:deref\n            :fn\n            :list\n            :map\n            :quote\n            :reader-macro\n            :reader-conditional\n            :reader-conditional-splice\n            :set\n            :syntax-quote\n            :uneval\n            :unquote\n            :unquote-splicing\n            :var\n            :vector\n            :regex) (wrap-children indent loc children)\n           (:meta :reader-meta) (wrap-children indent loc children)\n           :string (str \\\" value \\\")\n           :comment (str \\; value)\n           :comment-block (string/join (sequence (comp (map #(if (.test #\"^\\s*$\" %)\n                                                               %\n                                                               (str \";; \" %)))\n                                                       (interpose \"\\n\"))\n                                                 (string/split-lines value)))\n\n           :keyword (if (:resolve-ns? options)\n                      (str \"::\" (some-> (namespace value) (str \"/\")) (name value))\n                      (str value))\n\n           nil \"\")))))\n  ([loc]\n   (string 0 (cond-> loc\n                     (and loc\n                          (not= (type loc) z/ZipperLocation))\n                     (n/ast-zip)))))\n\n(declare sexp)\n\n(def splice? #{:reader-conditional-splice\n\n               #_:unquote-splicing})\n\n\n(defn as-code [forms]\n  (reduce (fn [out {:keys [tag] :as item}]\n            (if (tag-for-print-only? tag)\n              out\n              (let [value (sexp item)]\n                (if (nil? value)\n                  out\n                  ((if (contains? splice? tag) into conj)\n                   out value))))) [] forms))\n\n(defn sexp [{:keys [tag value children options] :as node}]\n  (when node\n    (if (= :error tag)\n      (throw (#?(:cljs js/Error.\n                 :clj  Exception.) node))\n      (case tag\n        :base (as-code children)\n\n        (:space\n         :newline\n         :comma\n         :cursor) nil\n\n        (:selection) (some-> (seq children) (as-code))\n\n        :string value\n\n        :unmatched-delimiter ::INVALID_TOKEN\n\n        :deref (template (deref ~(first (as-code children))))\n\n        (:token\n         :number) (try (edn/read-string value)\n                       (catch js/Error e ::INVALID_TOKEN))\n\n        :vector (vec (as-code children))\n\n        :list (apply list (as-code children))\n\n        :fn (fn-walk (first (as-code children)))\n\n        :map (apply hash-map (as-code children))\n\n        :set (template #{~@(as-code (:children (first children)))})\n\n        :var (template #'~(first (as-code children)))\n\n        (:quote :syntax-quote) (template (quote ~(first (as-code children))))\n\n        :unquote (template (~'clojure.core/unquote ~(first (as-code children))))\n\n        :unquote-splicing (template (~'clojure.core/unquote-splicing ~(first (as-code children))))\n\n        :reader-macro (r/read-string (string node))\n\n        (:reader-conditional\n         :reader-conditional-splice)\n        (let [[feature form] (->> (remove #(tag-for-print-only? (:tag %)) (:children (first children)))\n                                  (partition 2)\n                                  (filter (fn [[{feature :value} _]] (contains? *features* feature)))\n                                  (first))]\n          (if feature\n            (sexp form)\n            nil))\n\n        (:meta\n         :reader-meta) (let [[m data] (as-code children)]\n                         (cond-> data\n                                 #?(:cljs (satisfies? IWithMeta data)\n                                    :clj  (instance? clojure.lang.IMeta data))\n                                 (with-meta (if (map? m) m {m true}))))\n\n        :regex (re-pattern (first (as-code children)))\n\n        :keyword (if (:resolve-ns? options)\n                   (let [resolved-ns (if-let [the-ns (namespace value)]\n                                       (str (get r/*alias-map* (symbol the-ns) the-ns))\n                                       *ns*)]\n                     (keyword resolved-ns (name value)))\n                   value)\n\n        (:comment\n         :comment-block\n         :uneval) nil))))\n"]}
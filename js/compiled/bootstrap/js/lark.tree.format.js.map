{"version":3,"sources":["lark/tree/format.cljc"],"mappings":"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","names":["lark.tree.format/SPACES","clojure.string.join.cljs$core$IFn$_invoke$arity$1","cljs.core.take.cljs$core$IFn$_invoke$arity$2","cljs.core.repeat.cljs$core$IFn$_invoke$arity$1","lark.tree.format/spaces","n","cljs.core.subs.cljs$core$IFn$_invoke$arity$3","lark.tree.format/*pretty*","lark.tree.format/emit-space?","loc","fast-zip.core/left","fast-zip.core/right","lark.tree.node/newline?","G__64740","fast-zip.core/node","lark.tree.format/indentation-for","x","G__64763","clojure.string/starts-with?","cljs.core/re-find","lark.tree.format/threading-node?","node","temp__5720__auto__","operator","and__4120__auto__","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","G__64766","cljs.core/first","clojure.string/ends-with?","p__64774","map__64775","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","lark.tree.format/node-length","column","end-column","tag","value","G__64785","cljs.core/Keyword","lark.tree.reader/*active-cursor-node*","cljs.core/count","lark.tree.format/whitespace-tag?","t","cljs.core/keyword-identical?","lark.tree.format/butlast-vec","v","G__64790","cljs.core/empty?","cljs.core/pop","var_args","G__64797","lark.tree.format/body-indent*","js/Error","indent-level","lark.tree.format.body_indent_STAR_.cljs$core$IFn$_invoke$arity$3","child","children","threading?","G__64803","fast-zip.core/up","indent-type","cljs.core/name","G__64805","vec__64806","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","indent-offset","G__64809","split-after","exact?","taken","_","num-passed","G__64810","lark.tree.node/whitespace?","lark.tree.reader/split-after-n","lark.tree.node/sexp?","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","cljs.core/+","cljs.core.mapv.cljs$core$IFn$_invoke$arity$2","cljs.core/not","lark.tree.format/indentation-parent?","lark.tree.format/body-indent-string","pos","child-loc","temp__5718__auto__","coll-loc","cljs.core/iterate","cljs.core.sequence.cljs$core$IFn$_invoke$arity$2","cljs.core.comp.cljs$core$IFn$_invoke$arity$3","cljs.core.take_while.cljs$core$IFn$_invoke$arity$1","cljs.core/identity","p1__64813#","cljs.core.filter.cljs$core$IFn$_invoke$arity$1","G__64816","G__64817","lark.tree.range/within-inner?","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","coll-node","left-edge-width","lark.tree.reader/edges","body-indent","lark.tree.format/pad-chars?","c1","c2","lark.tree.reader/close-bracket?","lark.tree.reader/open-bracket?","lark.tree.reader/prefix-boundary?"],"sourcesContent":["(ns lark.tree.format\n  (:require [clojure.string :as str]\n            [lark.tree.reader :as rd]\n            [lark.tree.node :as n]\n            [lark.tree.util :as util]\n            [lark.tree.range :as range]\n            [fast-zip.core :as z]))\n\n(def SPACES (str/join (take 200 (repeat \" \"))))\n\n(defn spaces [n]\n  (subs SPACES 0 n))\n\n(def ^:dynamic *pretty* false)\n\n(defn emit-space? [loc]\n  (and (some? (z/left loc))\n       (some? (z/right loc))\n       (not (n/newline? (some-> (z/left loc)\n                                (z/node))))))\n\n(defn indentation-for [x]\n  (case x\n\n    (\"bound-fn\" \"extend\" \"extend-protocol\" \"extend-type\" \"fn\" \"ns\" \"reify\")\n    :indent\n\n    (\"cond\" \"do\" \"finally\" \"try\" \"with-out-str\" \"go\")\n    0\n\n    (\"assoc\" \"apply\" \"binding\" \"case\" \"definterface\" \"defstruct\" \"deftype\" \"doseq\" \"dotimes\" \"doto\"\n     \"for\" \"if\" \"if-let\" \"if-not\" \"if-some\" \"let\" \"letfn\" \"locking\" \"loop\"\n     \"struct-map\" \"when\" \"when-first\" \"when-let\" \"when-not\" \"when-some\"\n     \"while\" \"with-bindings\" \"with-local-vars\" \"with-open\" \"with-redefs\"\n     \"with-redefs-fn\" \"go-loop\" \"are\" \"deftest\" \"testing\")\n    1\n\n    (\"catch\" \"condp\" \"proxy\")\n    2\n    (cond (str/starts-with? x \"def\") :indent\n          (re-find #\"with|when|if\" x) 1\n          ;(str/ends-with? x \"->\") 1\n          :else 0)))\n\n(defn threading-node?\n  [node]\n  (when-let [operator (and (= (.-tag node) :list)\n                           (some-> node\n                                   (.-children)\n                                   (first)))]\n    (and (= :token (.-tag operator))\n         (str/ends-with? (.-value operator) \"->\"))))\n\n(defn node-length [{:as node :keys [column end-column tag value]}]\n  (case tag :space (if (= node rd/*active-cursor-node*)\n                     (count value)\n                     1)\n            :tab 1\n            (:cursor :selection) 0\n            (- end-column column)))\n\n(defn whitespace-tag? [t]\n  (util/contains-identical-keyword? [:space :cursor :selection :tab :newline]\n                                    t))\n\n(defn butlast-vec [v]\n  (cond-> v\n          (not (empty? v)) (pop)))\n\n(defn body-indent*\n  ([indent-level node] (body-indent* indent-level node nil))\n  ([indent-level loc child]\n   (assert (number? indent-level))\n   (let [node (.-node loc)\n         tag (.-tag node)\n         children (.-children node)\n         operator (first children)\n         threading? (and (= tag :list)\n                         (some-> (z/up loc)\n                                 (.-node)\n                                 (threading-node?)))]\n     (if (and (= :list tag)\n              operator\n              (= :token (.-tag operator)))\n       (let [indent-type (indentation-for (name (.-value operator)))]\n         (case indent-type\n           :indent (+ indent-level 1)\n           (let [indent-offset (-> indent-type\n                                   (cond-> threading? (dec)))\n                 split-after (+ 2 indent-offset)\n                 [exact? taken _ num-passed] (->> (cond-> children\n                                                          (n/whitespace? operator) (butlast-vec))\n                                                  (rd/split-after-n split-after\n                                                                    n/sexp?\n                                                                    (fn [node]\n                                                                      (or (= :newline (.-tag node))\n                                                                          (= node child)))))]\n             (+ indent-level (cond exact? (reduce + 0 (mapv node-length (pop taken)))\n                                   (and (= num-passed 1)\n                                        (not threading?)) 0\n                                   :else 1)))))\n       (+ indent-level)))))\n\n\n(defn indentation-parent? [node]\n  (util/contains-identical-keyword? [:vector :list :map] (.-tag node)))\n\n(defn body-indent-string [pos child-loc]\n  (if-let [coll-loc (->> (iterate z/up child-loc)\n                         (sequence (comp (take-while identity)\n                                         (filter #(range/within-inner? (z/node %) pos))\n                                         (filter (comp indentation-parent? z/node))))\n                         (first))]\n    (let [coll-node (z/node coll-loc)]\n      (let [child (z/node child-loc)\n            left-edge-width (count (first (get rd/edges (.-tag coll-node))))\n            body-indent (+ left-edge-width (body-indent* (:column coll-node) coll-loc child))]\n        (spaces body-indent)))\n    0))\n\n(defn pad-chars?\n  \"Returns true if space should be left inbetween characters c1 and c2.\"\n  [c1 c2]\n  (if (or (rd/close-bracket? c2)\n          (rd/open-bracket? c1)\n          (rd/prefix-boundary? c1)\n          (= \\# c1))\n    false\n    true))"]}
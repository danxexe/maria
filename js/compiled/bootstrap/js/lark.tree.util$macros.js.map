{"version":3,"sources":["lark/tree/util$macros.cljc"],"mappings":";;AAyBA,AAAA,AAAMA,AAAUC;AAAhB,AACE,AAAM,AAAK,AAASA,AAAG,AAAK,AAAA,AAAYA;AAAxC,AACEA;;AADF;;;AAGF,AAAA,AAAMC,AAASC,AAAEC;AAAjB,AACE,AAAM,AAACA,AAAAA,AAAAA,AAAED,AAAAA;AAAT,AAAYA;;AAAZ;;;AAEF,AAAA,AAAME,AAAUD,AAAED;AAAlB,AACE,AAAM,AAACC,AAAAA,AAAAA,AAAED,AAAAA;AAAT,AAAYA;;AAAZ;;;AAEO,AAAA,AAAMG;AAAN,AACE,AAAA,AAAK,AAAO,AAAAE;AAAZ,AAAA,AAAAD,AACYC;AADZ,AAAAD,AACqBE;AADrB,AAEO,AAACC,AAAe,AAASD;;AAFhC,AAAA,AAAAF","names":["lark.tree.util$macros/some-str","s","lark.tree.util$macros/guard->","x","f","lark.tree.util$macros/guard->>","lark.tree.util$macros/log-current-stack","e70698","js/Error","e","js/console.log"],"sourcesContent":["(ns lark.tree.util\n  #?(:cljs (:require-macros\n            [net.cgrand.macrovich :as macros]\n            [lark.tree.util])\n     :clj\n           (:require [net.cgrand.macrovich :as macros])))\n\n;; Successive `identical?` comparisons are _significantly_ faster than idiomatic alternatives such as `(contains? #{:k1 :k2} the-keyword)`,\n;; results in a 2x overall speedup in parse/ast.\n\n#?(:clj\n   (defmacro contains-identical-keyword?\n     \"Returns true if `x` is identical to any item in `coll` (expands to sequential `keyword-identical?` (cljs) or `identical?` (clj) comparisons).\"\n     [coll x]\n     `(or ~@(for [option coll]\n              `((macros/case :clj ~'identical? :cljs ~'keyword-identical?)\n                ~option ~x)))))\n\n#?(:clj\n   (defmacro contains-identical?\n     \"Returns true if `x` is identical to any item in `coll` (expands to sequential `identical?` comparisons).\"\n     [coll x]\n     `(or ~@(for [option coll]\n              `(identical? ~option ~x)))))\n\n(defn some-str [s]\n  (when (and (string? s) (not (identical? s \"\")))\n    s))\n\n(defn guard-> [x f]\n  (when (f x) x))\n\n(defn guard->> [f x]\n  (when (f x) x))\n\n#?(:cljs (defn log-current-stack []\n           (try (throw (js/Error.))\n                (catch js/Error e\n                  (js/console.log (.-stack e))))))"]}
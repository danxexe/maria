{"version":3,"sources":["chia/util/perf.cljc"],"mappings":";;;;;AAOA,AASA,AAIA,AAQA,AAMA,AAWA,AAIA,AAAA,AAAMA,AAAUC;AAAhB,AACE,AAAAC,AAAQD;AAAR,AAAA,AACQ,AAAA,AAAG,AAACE,AAAMF;AAAM,AAAAC,AAACE;;AADzBF;;;AAGF,AAAA,AAAMG,AAAOJ;AAAb,AACE,AAAMK,AAAI,AAACH,AAAMF;AAAjB,AACE,AAAU,AAAA,AAAOK;AAAjB;;AAAA,AACE,AAACC,AAAKN;;;AAEZ,AAAA,AAAMO,AAAaC,AAAKR;AAAxB,AACE,AAACS,AAAMD,AAAK,AAAA,AAAK,AAACN,AAAMM,AAAOR;;AAEjC,AAAA,AAAMU,AAAcF,AAAKG;AAAzB,AACE,AAACC,AAAOJ,AAAK,AAAA,AAAK,AAACN,AAAMM,AAAOG;;AAElC,AAAA,AAAME,AAAMF,AAAEG;AAAd,AACW,AAACC,AAAO,AAAKC,AAAIC;AAAT,AAAY,AAAAC,AAASF;AAAT,AAAA,AAAAE,AAAa,AAACP,AAAAA,AAAAA,AAAEM,AAAAA;;AAAhBC;AAApB,AAA+CJ;;AAG1D,AAIA","names":["chia.util.perf/butlastv","v","G__56977","cljs.core/count","cljs.core/pop","chia.util.perf/lastv","len","cljs.core/peek","chia.util.perf/assoc-lastv","path","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","chia.util.perf/update-lastv","f","cljs.core.update.cljs$core$IFn$_invoke$arity$3","chia.util.perf/mapa","s","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","out","x","array56979"],"sourcesContent":["(ns chia.util.perf\n  (:refer-clojure :exclude [str identical? array aget])\n  (:require [clojure.core :as core]\n            [chia.util.macros :as m]\n            #?(:cljs [applied-science.js-interop :as j]))\n  #?(:cljs (:require-macros [chia.util.perf])))\n\n(m/defmacro str\n  [x y]\n  (m/case :cljs `(let [x# ~x\n                       x# (if (some? x#) x# \"\")]\n                   (if-some [y# ~y]\n                     (~'js* \"~{} += ~{}\" x# y#)\n                     x#))\n          :clj `(core/str ~x ~y)))\n\n(m/defmacro kw== [x y]\n  #?(:cljs `(core/keyword-identical? ~x ~y)\n     :clj  `(core/identical? ~x ~y)))\n\n(m/defmacro identical? [a b]\n  (m/case :clj `(core/identical? ~a ~b)\n          :cljs (if (keyword? a)\n                  `(and (keyword? ~b)\n                        (core/identical? (.-fqn ~a)\n                                         (.-fqn ~b)))\n                  `(core/identical? ~a ~b))))\n\n(m/defmacro identical-in?\n  \"Returns true if `x` is identical to any item in `coll` (expands to sequential `identical?` comparisons).\"\n  [coll x]\n  `(or ~@(for [option coll]\n           `(identical? ~option ~x))))\n\n(m/defmacro keyword-in?\n  \"Returns true if `x` is identical to any item in `coll` (expands to sequential `keyword-identical?` (cljs) or `identical?` (clj) comparisons).\"\n  [coll x]\n  (let [x-sym (gensym \"x\")]\n    `(do (assert (keyword ~x))\n         (let [~x-sym ~(m/case :cljs `(~'.-fqn ~x)\n                               :clj x)]\n           (or ~@(for [option coll]\n                   `(core/identical? ~(m/case :cljs `(~'.-fqn ~option)\n                                              :clj option) ~x-sym)))))))\n\n(m/defmacro unchecked-kw-identical? [a b]\n  (m/case :cljs `(core/identical? (.-fqn ~a) (.-fqn ~b))\n          :clj `(core/identical? ~a ~b)))\n\n(defn butlastv [v]\n  (cond-> v\n          (> (count v) 0) (pop)))\n\n(defn lastv [v]\n  (let [len (count v)]\n    (when-not (zero? len)\n      (peek v))))\n\n(defn assoc-lastv [path v]\n  (assoc path (dec (count path)) v))\n\n(defn update-lastv [path f]\n  (update path (dec (count path)) f))\n\n(defn mapa [f s]\n  #?(:cljs (reduce (fn [out x] (j/push! out (f x))) #js[] s)\n     :clj  (reduce (fn [out x] (conj out (f x))) [] s)))\n\n(m/defmacro array [& items]\n  `(~(m/case :clj 'vector :cljs 'array)\n    ~@items))\n\n(m/defmacro aget [a n]\n  `(~(m/case :clj `nth :cljs `core/aget) ~a ~n))"]}
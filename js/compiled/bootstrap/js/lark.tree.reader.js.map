{"version":3,"sources":["lark/tree/reader.cljc"],"mappings":"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","names":["lark.tree.reader/*invalid-nodes*","lark.tree.reader/*active-cursor-node*","lark.tree.reader/*delimiter*","lark.tree.reader/peek","cljs.tools.reader.reader-types/peek-char","lark.tree.reader/current-offset","indexing-pushback-reader","pushback-reader","indexing-reader","pushback","lark.tree.reader/edges","lark.tree.reader/whitespace-tag?","tag","cljs.core/keyword-identical?","lark.tree.reader/close-bracket?","ch","lark.tree.reader/open-bracket?","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","lark.tree.reader/throw-reader","seq63057","G__63058","cljs.core/first","cljs.core/next","G__63059","self__4717__auto__","reader","fmt","data","c","l","js/Error","lark.tree.reader/buf","js/goog.string.StringBuffer","lark.tree.reader/read-while","p__63070","vec__63071","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","seq63066","G__63067","G__63068","p?","eof?","cljs.core/not","temp__5718__auto__","cljs.tools.reader.reader-types/read-char","cljs.tools.reader.reader-types/unread","lark.tree.reader/read-until","lark.tree.reader.read_while.cljs$core$IFn$_invoke$arity$variadic","cljs.core/complement","lark.tree.reader/next","lark.tree.reader/ignore","lark.tree.reader/unread","lark.tree.reader/position","x__4433__auto__","m__4434__auto__","lark.tree.reader/assoc-range!","goog/typeOf","m__4431__auto__","cljs.core/missing-protocol","lark.tree.reader/IRange","this","position","lark.tree.reader/append","lark.tree.reader/IAppend","x","cljs.core/PROTOCOL_SENTINEL","this__4374__auto__","writer__4375__auto__","opt__4376__auto__","cljs.core/-write","lark.tree.reader/Node","lark.tree.reader/->Node","options","range","value","children","coll","o","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","other","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","y","cljs.core._lookup.cljs$core$IFn$_invoke$arity$2","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","key","G__63168","cljs.core/Keyword","cljs.core/meta","cljs.core/contains?","k","VAL","G__63186","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","val","G__63098","entry","cljs.core/vector?","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","cljs.core/-conj","not-found","or__4131__auto__","G__63111","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","cljs.core.get.cljs$core$IFn$_invoke$arity$3","writer","_","G__63118","cljs.core.dissoc.cljs$core$IFn$_invoke$arity$variadic","cljs.core/seq","G__63124","cljs.core.into.cljs$core$IFn$_invoke$arity$2","lark.tree.reader/delimiter-error","vec__63195","line","col","lark.tree.reader/current-pos","lark.tree.reader/read-with-position","read-fn","start-line","start-column","start-offset","temp__5720__auto__","node","lark.tree.reader/report-invalid!","G__63206","cljs.core/-vreset!","cljs.core/-deref","G__63213","lark.tree.reader/InvalidToken!","lark.tree.reader.InvalidToken_BANG_.cljs$core$IFn$_invoke$arity$3","G__63223","lark.tree.reader/Splice","lark.tree.reader.Splice.cljs$core$IFn$_invoke$arity$1","lark.tree.reader/CollectionNode","nodes","lark.tree.reader/ValueNode","lark.tree.reader/EmptyNode","lark.tree.reader/split-after-n","n","pred","stop?","remaining","i","taken","cljs.core/empty?","next-item","and__4120__auto__","count-it?","cljs.core.subvec.cljs$core$IFn$_invoke$arity$2","G__63233","p__63237","map__63238","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","count-pred","lark.tree.reader/take-children","take-n","out","cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic","js/console.error","map__63253","next-node","next-i","G__63262","G__63263","cljs.core/set","p__63278","map__63282","lark.tree.reader/conj-children","coll-node","vec__63284","inner-line","inner-col","inner-offset","coll-tag","invalid-exit","G__63287","lark.tree.reader.Splice.cljs$core$IFn$_invoke$arity$2","vec__63291","left","right","width","cljs.core/count","cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$variadic","cljs.core.assoc_BANG_.cljs$core$IFn$_invoke$arity$3","map__63322","G__63327","G__63331","vec__63332","valid?","taken-values","remaining-values","lark.tree.reader/NodeWithChildren","delimiter","*delimiter*-orig-val__63341","*delimiter*-temp-val__63342","cljs.core/cons","lark.tree.reader/read-string-data","escape?","cljs.core.assoc.cljs$core$IFn$_invoke$arity$variadic","lark.tree.reader/non-breaking-space","lark.tree.reader/newline?","lark.tree.reader/space?","lark.tree.reader/whitespace?","lark.tree.reader/brace?","lark.tree.reader/prefix-boundary?","lark.tree.reader/boundary?","cljs.core/List"],"sourcesContent":["(ns lark.tree.reader\n  (:refer-clojure :exclude [peek next])\n  (:require\n   [lark.tree.util :as util]\n   #?(:cljs [cljs.tools.reader.reader-types :as r]\n      :clj\n   [clojure.tools.reader.reader-types :as r]))\n  #?(:cljs (:import [goog.string StringBuffer])))\n\n(def ^:dynamic *invalid-nodes* nil)\n(def ^:dynamic *active-cursor-node* nil)\n\n(def ^:dynamic *delimiter* (list))\n\n(def peek r/peek-char)\n\n(defn current-offset [indexing-pushback-reader]\n  (let [pushback-reader (.-rdr indexing-pushback-reader)\n        indexing-reader (.-rdr pushback-reader)\n        pushback (- (.-buf_len pushback-reader)\n                    (.-buf_pos pushback-reader))]\n    (- (.-s_pos indexing-reader)\n       pushback)))\n\n(def edges\n  {:deref [\"@\"]\n   :list [\\( \\)]\n   :fn [\"#\"]\n   :map [\\{ \\}]\n   :meta [\"^\"]\n   :quote [\"'\"]\n   :reader-meta [\"#^\"]\n   :raw-meta [\"^\"]\n   :reader-macro [\"#\"]\n   :regex [\"#\"]\n   :set [\"#\"]\n   :string [\\\" \\\"]\n   :syntax-quote [\"`\"]\n   :unquote [\"~\"]\n   :unquote-splicing [\"~@\"]\n   :uneval [\"#_\"]\n   :var [\"#'\"]\n   :vector [\\[ \\]]\n   :reader-conditional [\"#?\"]\n   :reader-conditional-splice [\"#?@\"]\n   :selection [\\\u2039 \\\u203a]})\n\n(defn whitespace-tag? [tag]\n  (util/contains-identical-keyword?\n   [:space :newline :tab :comma :cursor :selection]\n   tag))\n\n(defn close-bracket? [ch]\n  (util/contains-identical? [\\) \\] \\}] ch))\n\n(defn open-bracket? [ch]\n  (util/contains-identical? [\\( \\[ \\{] ch))\n\n(defn throw-reader\n  \"Throw reader exception, including line/column.\"\n  [reader fmt & data]\n  (let [c (.-column reader)\n        l (.-line reader)]\n    (throw\n     (#?(:cljs js/Error.\n         :clj  Exception.)\n      (str fmt data\n           \" [at line \" l \", column \" c \"]\")))))\n\n(def buf #?(:cljs (StringBuffer.)\n            :clj  (StringBuilder.)))\n\n(defn read-while\n  \"Read while the chars fulfill the given condition. Does not consume the unmatching char.\"\n  [reader p? & [eof?]]\n  (let [eof? (if ^boolean (nil? eof?)\n               (not (p? nil))\n               eof?)]\n    #?(:cljs (.clear buf)\n       :clj  (.setLength buf 0))\n    (loop []\n      (if-let [c (r/read-char reader)]\n        (if ^boolean (p? c)\n          (do\n            (.append buf c)\n            (recur))\n          (do\n            (r/unread reader c)\n            #?(:cljs (.toString buf)\n               :clj  (str buf))))\n        (if ^boolean eof?\n          #?(:cljs (.toString buf)\n             :clj  (str buf))\n          (throw-reader reader \"Unexpected EOF.\"))))))\n\n(defn read-until\n  \"Read until a char fulfills the given condition. Does not consume the matching char.\"\n  [reader p?]\n  (read-while reader (complement p?) (p? nil)))\n\n(defn next\n  \"Read next char.\"\n  [reader]\n  (r/read-char reader))\n\n(defn ignore\n  \"Ignore the next character.\"\n  [reader]\n  (r/read-char reader))\n\n(defn unread\n  \"Unreads a char. Puts the char back on the reader.\"\n  [reader ch]\n  (r/unread reader ch))\n\n(defn position\n  \"Returns 0-indexed vector of [line, column] for current reader position.\"\n  [reader]\n  [(dec (.-line reader))\n   (dec (.-column reader))])\n\n;; TODO\n;; :value => (first children)\n;; first, last, rest, etc. -- operate on children\n;; seq -- returns children\n\n(defprotocol IRange\n  ;; mutates range of node -- for internal parser use\n  (assoc-range! [this position]))\n\n(defprotocol IAppend\n  (append [this x]))\n\n(deftype Node [^:mutable tag\n               ^:mutable options\n               ^:mutable range\n               ^:mutable value\n               ^:mutable children]\n\n  ;; ------------- Add child nodes via `append` --------------\n\n  IAppend\n  (append [coll o]\n    (Node. tag options range value (conj children o)))\n\n  ;; ------------- Position information stored via `meta` --------------\n\n  IRange\n  (assoc-range! [this position]\n    (set! range position)\n    this)\n\n  ;; ------------- Equality --------------\n\n  IEquiv\n  (-equiv [o other]\n   ;; position not taken into account\n    (and (some? other)\n         (= tag (.-tag other))\n         (= children (.-children other))\n         (= value (.-value other))\n         (= range (.-range other))\n         (= options (.-options other))))\n\n  ;; ------------- Comparison by range --------------\n\n  IComparable\n  (-compare [x y]\n    (let [l (- (-lookup x :line) (-lookup y :line))]\n      (if (not= l 0)\n        l\n        (- (-lookup x :column) (-lookup y :column)))))\n\n  ;; ------------- Associative operations on `options` --------------\n\n  IAssociative\n  (-contains-key? [this key]\n    (case key :tag true\n              (:line\n               :column\n               :end-line\n               :end-column) (some? meta)\n              :value (some? value)\n              :children (some? children)\n              :range (some? range)\n              (contains? options key)))\n  (-assoc [this k VAL]\n    (case k\n      :tag (Node. VAL options range value children)\n      :value (Node. tag options range VAL children)\n      :children (Node. tag options range value VAL)\n      :range (Node. tag options VAL value children)\n      (Node. tag (assoc options k VAL) range value children)))\n\n  ITransientAssociative\n  (-assoc! [this k val]\n    (case k\n      :tag (set! tag val)\n      :value (set! value val)\n      :children (set! children val)\n      :range (set! range val)\n      :options (set! options val))\n    this)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  ;; `get` supports direct access to tag, value, and positional elements\n\n  ILookup\n  (-lookup [this key]\n    (-lookup this key nil))\n  (-lookup [this key not-found]\n    (or (case key :tag tag\n                  :value value\n                  :children children\n                  :range range\n                  :line (nth range 0)\n                  :column (nth range 1)\n                  :end-line (nth range 2)\n                  :end-column (nth range 3)\n                  :offset (nth range 4)\n                  :end-offset (nth range 5)\n                  :options options\n\n                  ;; todo\n                  ;; see if we should keep this\n                  :start {:line (nth range 0)\n                          :column (nth range 1)}\n                  :end {:line (nth range 2)\n                        :column (nth range 3)}\n                  nil)\n        (get options key not-found)))\n\n  ;; for debugging\n  IPrintWithWriter\n  (-pr-writer [o writer _]\n    (let [options (cond-> (dissoc options :source :invalid-nodes :cursor)\n                          range (assoc :range range))]\n      (-write writer (str (if (or children (seq options))\n                            (cond-> [tag]\n                                    options (conj options)\n                                    value (conj value)\n                                    children (into children))\n                            tag))))))\n\n(defn delimiter-error [tag reader]\n  (let [[line col] (position reader)]\n    (Node. :error {:tag tag\n                   :expected (first *delimiter*)} [line\n                                                   col\n                                                   line\n                                                   (inc col)] nil nil)))\n\n(defn current-pos [reader]\n  [(dec (.-line reader))\n   (dec (.-column reader))])\n\n(defn read-with-position\n  \"Use the given function to read value, then attach row/col metadata.\"\n  [reader read-fn]\n  (let [start-line (dec (.-line reader))\n        start-column (dec (.-column reader))\n        start-offset (current-offset reader)]\n    (when-let [node (read-fn reader)]\n      (assoc-range!\n       node\n       [start-line\n        start-column\n\n        (dec (.-line reader))\n        (dec (.-column reader))\n\n        start-offset\n        (current-offset reader)]))))\n\n(defn report-invalid! [node]\n  (let [node (assoc node :invalid? true)]\n    (some-> *invalid-nodes*\n            (vswap! conj node))\n    node))\n\n(defn InvalidToken!\n  ([tag value] (InvalidToken! tag value nil))\n  ([tag value position]\n   (report-invalid!\n    (->Node :token {:invalid? true\n                    :info {:tag tag}} position value nil))))\n\n(defn Splice\n  ([children]\n   (->Node :splice nil nil nil children))\n  ([node children]\n   (Splice (into [node] children))))\n\n(defn CollectionNode [tag nodes]\n  (->Node tag nil nil nil nodes))\n\n(defn ValueNode [tag value]\n  (->Node tag nil nil value nil))\n\n(defn EmptyNode [tag]\n  (->Node tag nil nil nil nil))\n\n(defn split-after-n\n  \"Splits after `n` values which pass `pred`.\n\n  Returns vector of the form\n  [<took-n-values?> <taken-values> <remaining-values>]\"\n  [n pred stop? coll]\n  (loop [remaining coll\n         i 0\n         taken []]\n    (cond (= i n)\n          [true taken remaining i]\n          (empty? remaining)\n          [false taken remaining i]\n          :else\n          (let [next-item (nth remaining 0)]\n            (if (and (some? stop?) (stop? next-item))\n              [false taken remaining i]\n              (let [count-it? (pred next-item)]\n                (recur (subvec remaining 1)\n                       (cond-> i\n                               count-it? (inc))\n                       (conj taken next-item))))))))\n\n(defn take-children\n  [reader {:keys [:read-fn\n                  :count-pred]\n           take-n :take-n}]\n  ;; returns `child-values, remaining-values, valid?`\n  (loop [reader reader\n         i 0\n         out []]\n    (if (> i 10000)\n      (do\n        (prn :take-children out)\n        (js/console.error (js/Error. \"Infinite loop?\"))\n        [false out nil])\n      (if (and (some? take-n) (= i take-n))\n        [true out nil]\n        (let [{:keys [tag value children] :as next-node} (read-fn reader)\n              next-i (if (and (some? take-n) (some? count-pred))\n                       (cond-> i\n                               (count-pred next-node) (inc))\n                       (inc i))]\n          (case tag\n            :unmatched-delimiter\n            (if\n             (contains? (set *delimiter*) value)            ;; can match prev\n              (do\n                (unread reader value)\n                [false out nil])\n              (recur reader next-i (conj out (report-invalid! next-node))))\n\n            :splice\n            (if take-n\n              (split-after-n take-n count-pred nil children)\n              (recur reader next-i (into out children)))\n\n            (:eof nil)\n            [false out nil]\n\n            :matched-delimiter\n            (if (and take-n (not= take-n i))\n              (do (unread reader value)\n                  [false out nil])\n              [true out nil])\n\n            (recur reader next-i (conj out next-node))))))))\n\n(defn conj-children\n  [coll-node reader {:keys [:read-fn\n                            :count-pred]\n                     take-n :take-n}]\n  (let [[inner-line inner-col] (current-pos reader)\n        inner-offset (current-offset reader)\n        coll-tag (.-tag coll-node)\n        invalid-exit (fn [out]\n                       (case coll-tag\n                         :base (assoc coll-node :children out)\n                         (Splice (let [[left right] (get edges coll-tag)\n                                       width (count left)]\n                                   (report-invalid!\n                                    (-> (EmptyNode :unmatched-delimiter)\n                                        (assoc!\n                                         :options {:info {:tag coll-tag\n                                                          :direction :forward\n                                                          :expects right}}\n                                         :range [inner-line\n                                                 (- inner-col width)\n                                                 inner-line\n                                                 inner-col\n                                                 (- inner-offset width)\n                                                 inner-offset]\n                                         :value left)))) out)))]\n    (loop [reader reader\n           i 0\n           out []]\n      (if (> i 10000)\n        (do\n          (js/console.error (js/Error. \"Infinite loop?\"))\n          (assoc! coll-node :children out))\n        (if (and (some? take-n) (= i take-n))\n          (assoc! coll-node :children out)\n          (let [{:keys [tag value children] :as next-node} (read-fn reader)\n                next-i (if (and (some? take-n) (some? count-pred))\n                         (cond-> i\n                                 (count-pred next-node) (inc))\n                         (inc i))]\n            (case tag\n              :unmatched-delimiter\n              (if\n               (contains? (set *delimiter*) value)          ;; can match prev\n                (do\n                  (unread reader value)\n                  (invalid-exit out))\n                (recur reader next-i (conj out (report-invalid! next-node))))\n\n              :splice\n              (if take-n\n                (let [[valid? taken-values remaining-values] (split-after-n take-n count-pred nil children)]\n                  (if valid?\n                    (Splice (assoc! coll-node :children taken-values)\n                            remaining-values)\n                    (invalid-exit (into out children))))\n                (recur reader next-i (into out children)))\n\n              (:eof nil)\n              (invalid-exit out)\n\n              :matched-delimiter\n              (if (and take-n (not= take-n i))\n                (do (unread reader value)\n                    (invalid-exit out))\n                (assoc! coll-node :children out))\n\n              (recur reader next-i (conj out next-node)))))))))\n\n(defn NodeWithChildren\n  [reader read-fn tag delimiter]\n  (r/read-char reader)\n  (binding [*delimiter* (cons delimiter *delimiter*)]\n    (conj-children (EmptyNode tag) reader {:read-fn read-fn})))\n\n(defn read-string-data\n  [node reader]\n  (ignore reader)\n  #?(:cljs (.clear buf)\n     :clj  (.setLength buf 0))\n  (loop [escape? false]\n    (if-let [c (r/read-char reader)]\n      (cond (and (not escape?) (identical? c \\\"))\n            (assoc! node :value #?(:cljs (.toString buf)\n                                   :clj  (str buf)))\n            :else\n            (do\n              (.append buf c)\n              (recur (and (not escape?) (identical? c \\\\)))))\n      (report-invalid!\n       (assoc node :tag :token\n                   :options {:tag (:tag node)}\n                   :value (str \\\" #?(:cljs (.toString buf)\n                                     :clj  (str buf))))))))\n\n(def non-breaking-space \\u00A0)\n\n(defn newline?\n  [c]\n  (util/contains-identical? [\\newline\n                             \\return]\n                            c))\n\n(defn space?\n  [c]\n  (util/contains-identical? [\\space\n                             \\tab\n                             non-breaking-space]\n                            c))\n\n(defn whitespace?\n  [c]\n  (or (util/contains-identical? [\\,\n                                 \\space\n                                 \\tab\n                                 non-breaking-space]\n                                c)\n      (newline? c)))\n\n(defn brace? [ch]\n  (util/contains-identical? [\\( \\) \\[ \\] \\{ \\} \\\"]\n                            ch))\n\n(defn prefix-boundary? [ch]\n  (util/contains-identical? [\\; \\: \\' \\@ \\^ \\` \\~ \\\\ nil]\n                            ch))\n\n(defn boundary? [ch]\n  (or (brace? ch)\n      (prefix-boundary? ch)))"]}
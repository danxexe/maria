{"version":3,"sources":["maria/friendly/docstrings.cljs"],"mappings":";;AAQA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAKA","names":["maria.friendly.docstrings/clojure-core"],"sourcesContent":["(ns maria.friendly.docstrings)\n\n;; Currently using Markdowny strings\n\n;; Similar work (but complected with nREPL and having only one example) at https://github.com/tatut/nrepl-doc-inject\n;; Similar work (using adoc format and with longer/more extensive explanations) at https://github.com/Odie/sidedocs-clj-api-docs\n;; Similar work (started but only 2 examples) at https://github.com/ericnormand/ultra-docstrings/blob/master/src/ultra_docstrings/core.clj\n\n(def clojure-core\n  {\"map\" {:docstring \"Applies the given function `f` to each element of the collection `coll`.\n\nIf given more than one collection (e.g. `(map f c1 c2)`), applies the given function `f` to the set of first items of each coll, followed by applying f to the set of second items in each coll, until any one of the colls is exhausted. (Any remaining items in other collections are ignored.)\n\nReturns a lazy sequence, regardless of the type of the input collections. See `mapv` if you want a similar function that returns a vector.\n\nThe function `f` should accept the same number of arguments as the number of collections provided.\n\nReturns a [transducer](https://clojure.org/reference/transducers) when no collection is provided.\"}\n   \"fn\" {:docstring \"Defines a function that will evaluate its arguments `params*` (a vector of zero or more names) according to the expressions `exprs*`.\"}})\n"]}
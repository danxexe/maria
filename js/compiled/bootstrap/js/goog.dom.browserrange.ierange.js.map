{
"version":3,
"file":"goog.dom.browserrange.ierange.js",
"lineCount":518,
"mappings":"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",
"sources":["goog/dom/browserrange/ierange.js"],
"sourcesContent":["// Copyright 2007 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Definition of the IE browser specific range wrapper.\n * @suppress {missingRequire} Cannot depend on goog.dom.browserrange because it\n *     creates a circular dependency.\n *\n * DO NOT USE THIS FILE DIRECTLY.  Use goog.dom.Range instead.\n *\n * @author robbyw@google.com (Robby Walker)\n */\n\n\ngoog.provide('goog.dom.browserrange.IeRange');\n\ngoog.require('goog.array');\ngoog.require('goog.dom');\ngoog.require('goog.dom.NodeType');\ngoog.require('goog.dom.RangeEndpoint');\ngoog.require('goog.dom.TagName');\ngoog.require('goog.dom.browserrange.AbstractRange');\ngoog.require('goog.log');\ngoog.require('goog.string');\n\n\n\n/**\n * The constructor for IE specific browser ranges.\n * @param {TextRange} range The range object.\n * @param {Document} doc The document the range exists in.\n * @constructor\n * @extends {goog.dom.browserrange.AbstractRange}\n * @final\n */\ngoog.dom.browserrange.IeRange = function(range, doc) {\n  /**\n   * Lazy cache of the node containing the entire selection.\n   * @private {?Node}\n   */\n  this.parentNode_ = null;\n\n  /**\n   * Lazy cache of the node containing the start of the selection.\n   * @private {?Node}\n   */\n  this.startNode_ = null;\n\n  /**\n   * Lazy cache of the node containing the end of the selection.\n   * @private {?Node}\n   */\n  this.endNode_ = null;\n\n  /**\n   * Lazy cache of the offset in startNode_ where this range starts.\n   * @private {number}\n   */\n  this.startOffset_ = -1;\n\n  /**\n   * Lazy cache of the offset in endNode_ where this range ends.\n   * @private {number}\n   */\n  this.endOffset_ = -1;\n\n  /**\n   * The browser range object this class wraps.\n   * @private {TextRange}\n   */\n  this.range_ = range;\n\n  /**\n   * The document the range exists in.\n   * @private {Document}\n   */\n  this.doc_ = doc;\n};\ngoog.inherits(\n    goog.dom.browserrange.IeRange, goog.dom.browserrange.AbstractRange);\n\n\n/**\n * Logging object.\n * @type {goog.log.Logger}\n * @private\n */\ngoog.dom.browserrange.IeRange.logger_ =\n    goog.log.getLogger('goog.dom.browserrange.IeRange');\n\n\n/**\n * Returns a browser range spanning the given node's contents.\n * @param {Node} node The node to select.\n * @return {!TextRange} A browser range spanning the node's contents.\n * @private\n */\ngoog.dom.browserrange.IeRange.getBrowserRangeForNode_ = function(node) {\n  var nodeRange = goog.dom.getOwnerDocument(node).body.createTextRange();\n  if (node.nodeType == goog.dom.NodeType.ELEMENT) {\n    // Elements are easy.\n    nodeRange.moveToElementText(node);\n    // Note(user) : If there are no child nodes of the element, the\n    // range.htmlText includes the element's outerHTML. The range created above\n    // is not collapsed, and should be collapsed explicitly.\n    // Example : node = <div></div>\n    // But if the node is sth like <br>, it shouldn't be collapsed.\n    if (goog.dom.browserrange.canContainRangeEndpoint(node) &&\n        !node.childNodes.length) {\n      nodeRange.collapse(false);\n    }\n  } else {\n    // Text nodes are hard.\n    // Compute the offset from the nearest element related position.\n    var offset = 0;\n    var sibling = node;\n    while (sibling = sibling.previousSibling) {\n      var nodeType = sibling.nodeType;\n      if (nodeType == goog.dom.NodeType.TEXT) {\n        offset += sibling.length;\n      } else if (nodeType == goog.dom.NodeType.ELEMENT) {\n        // Move to the space after this element.\n        nodeRange.moveToElementText(sibling);\n        break;\n      }\n    }\n\n    if (!sibling) {\n      nodeRange.moveToElementText(node.parentNode);\n    }\n\n    nodeRange.collapse(!sibling);\n\n    if (offset) {\n      nodeRange.move('character', offset);\n    }\n\n    nodeRange.moveEnd('character', node.length);\n  }\n\n  return nodeRange;\n};\n\n\n/**\n * Returns a browser range spanning the given nodes.\n * @param {Node} startNode The node to start with.\n * @param {number} startOffset The offset within the start node.\n * @param {Node} endNode The node to end with.\n * @param {number} endOffset The offset within the end node.\n * @return {!TextRange} A browser range spanning the node's contents.\n * @private\n */\ngoog.dom.browserrange.IeRange.getBrowserRangeForNodes_ = function(\n    startNode, startOffset, endNode, endOffset) {\n  // Create a range starting at the correct start position.\n  var child, collapse = false;\n  if (startNode.nodeType == goog.dom.NodeType.ELEMENT) {\n    if (startOffset > startNode.childNodes.length) {\n      goog.log.error(\n          goog.dom.browserrange.IeRange.logger_,\n          'Cannot have startOffset > startNode child count');\n    }\n    child = startNode.childNodes[startOffset];\n    collapse = !child;\n    startNode = child || startNode.lastChild || startNode;\n    startOffset = 0;\n  }\n  var leftRange =\n      goog.dom.browserrange.IeRange.getBrowserRangeForNode_(startNode);\n\n  // This happens only when startNode is a text node.\n  if (startOffset) {\n    leftRange.move('character', startOffset);\n  }\n\n\n  // The range movements in IE are still an approximation to the standard W3C\n  // behavior, and IE has its trickery when it comes to htmlText and text\n  // properties of the range. So we short-circuit computation whenever we can.\n  if (startNode == endNode && startOffset == endOffset) {\n    leftRange.collapse(true);\n    return leftRange;\n  }\n\n  // This can happen only when the startNode is an element, and there is no node\n  // at the given offset. We start at the last point inside the startNode in\n  // that case.\n  if (collapse) {\n    leftRange.collapse(false);\n  }\n\n  // Create a range that ends at the right position.\n  collapse = false;\n  if (endNode.nodeType == goog.dom.NodeType.ELEMENT) {\n    if (endOffset > endNode.childNodes.length) {\n      goog.log.error(\n          goog.dom.browserrange.IeRange.logger_,\n          'Cannot have endOffset > endNode child count');\n    }\n    child = endNode.childNodes[endOffset];\n    endNode = child || endNode.lastChild || endNode;\n    endOffset = 0;\n    collapse = !child;\n  }\n  var rightRange =\n      goog.dom.browserrange.IeRange.getBrowserRangeForNode_(endNode);\n  rightRange.collapse(!collapse);\n  if (endOffset) {\n    rightRange.moveEnd('character', endOffset);\n  }\n\n  // Merge and return.\n  leftRange.setEndPoint('EndToEnd', rightRange);\n  return leftRange;\n};\n\n\n/**\n * Create a range object that selects the given node's text.\n * @param {Node} node The node to select.\n * @return {!goog.dom.browserrange.IeRange} An IE range wrapper object.\n */\ngoog.dom.browserrange.IeRange.createFromNodeContents = function(node) {\n  var range = new goog.dom.browserrange.IeRange(\n      goog.dom.browserrange.IeRange.getBrowserRangeForNode_(node),\n      goog.dom.getOwnerDocument(node));\n\n  if (!goog.dom.browserrange.canContainRangeEndpoint(node)) {\n    range.startNode_ = range.endNode_ = range.parentNode_ = node.parentNode;\n    range.startOffset_ = goog.array.indexOf(range.parentNode_.childNodes, node);\n    range.endOffset_ = range.startOffset_ + 1;\n  } else {\n    // Note(user) : Emulate the behavior of W3CRange - Go to deepest possible\n    // range containers on both edges. It seems W3CRange did this to match the\n    // IE behavior, and now it is a circle. Changing W3CRange may break clients\n    // in all sorts of ways.\n    var tempNode, leaf = node;\n    while ((tempNode = leaf.firstChild) &&\n           goog.dom.browserrange.canContainRangeEndpoint(tempNode)) {\n      leaf = tempNode;\n    }\n    range.startNode_ = leaf;\n    range.startOffset_ = 0;\n\n    leaf = node;\n    while ((tempNode = leaf.lastChild) &&\n           goog.dom.browserrange.canContainRangeEndpoint(tempNode)) {\n      leaf = tempNode;\n    }\n    range.endNode_ = leaf;\n    range.endOffset_ = leaf.nodeType == goog.dom.NodeType.ELEMENT ?\n        leaf.childNodes.length :\n        leaf.length;\n    range.parentNode_ = node;\n  }\n  return range;\n};\n\n\n/**\n * Static method that returns the proper type of browser range.\n * @param {Node} startNode The node to start with.\n * @param {number} startOffset The offset within the start node.\n * @param {Node} endNode The node to end with.\n * @param {number} endOffset The offset within the end node.\n * @return {!goog.dom.browserrange.AbstractRange} A wrapper object.\n */\ngoog.dom.browserrange.IeRange.createFromNodes = function(\n    startNode, startOffset, endNode, endOffset) {\n  var range = new goog.dom.browserrange.IeRange(\n      goog.dom.browserrange.IeRange.getBrowserRangeForNodes_(\n          startNode, startOffset, endNode, endOffset),\n      goog.dom.getOwnerDocument(startNode));\n  range.startNode_ = startNode;\n  range.startOffset_ = startOffset;\n  range.endNode_ = endNode;\n  range.endOffset_ = endOffset;\n  return range;\n};\n\n\n/**\n * @return {!goog.dom.browserrange.IeRange} A clone of this range.\n * @override\n */\ngoog.dom.browserrange.IeRange.prototype.clone = function() {\n  var range =\n      new goog.dom.browserrange.IeRange(this.range_.duplicate(), this.doc_);\n  range.parentNode_ = this.parentNode_;\n  range.startNode_ = this.startNode_;\n  range.endNode_ = this.endNode_;\n  return range;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.getBrowserRange = function() {\n  return this.range_;\n};\n\n\n/**\n * Clears the cached values for containers.\n * @private\n */\ngoog.dom.browserrange.IeRange.prototype.clearCachedValues_ = function() {\n  this.parentNode_ = this.startNode_ = this.endNode_ = null;\n  this.startOffset_ = this.endOffset_ = -1;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.getContainer = function() {\n  if (!this.parentNode_) {\n    var selectText = this.range_.text;\n\n    // If the selection ends with spaces, we need to remove these to get the\n    // parent container of only the real contents.  This is to get around IE's\n    // inconsistency where it selects the spaces after a word when you double\n    // click, but leaves out the spaces during execCommands.\n    var range = this.range_.duplicate();\n    // We can't use goog.string.trimRight, as that will remove other whitespace\n    // too.\n    var rightTrimmedSelectText = selectText.replace(/ +$/, '');\n    var numSpacesAtEnd = selectText.length - rightTrimmedSelectText.length;\n    if (numSpacesAtEnd) {\n      range.moveEnd('character', -numSpacesAtEnd);\n    }\n\n    // Get the parent node.  This should be the end, but alas, it is not.\n    var parent = range.parentElement();\n\n    var htmlText = range.htmlText;\n    var htmlTextLen = goog.string.stripNewlines(htmlText).length;\n    if (this.isCollapsed() && htmlTextLen > 0) {\n      return (this.parentNode_ = parent);\n    }\n\n    // Deal with selection bug where IE thinks one of the selection's children\n    // is actually the selection's parent. Relies on the assumption that the\n    // HTML text of the parent container is longer than the length of the\n    // selection's HTML text.\n\n    // Also note IE will sometimes insert \\r and \\n whitespace, which should be\n    // disregarded. Otherwise the loop may run too long and return wrong parent\n    while (htmlTextLen > goog.string.stripNewlines(parent.outerHTML).length) {\n      parent = parent.parentNode;\n    }\n\n    // Deal with IE's selecting the outer tags when you double click\n    // If the innerText is the same, then we just want the inner node\n    while (parent.childNodes.length == 1 &&\n           parent.innerText ==\n               goog.dom.browserrange.IeRange.getNodeText_(parent.firstChild)) {\n      // A container should be an element which can have children or a text\n      // node. Elements like IMG, BR, etc. can not be containers.\n      if (!goog.dom.browserrange.canContainRangeEndpoint(parent.firstChild)) {\n        break;\n      }\n      parent = parent.firstChild;\n    }\n\n    // If the selection is empty, we may need to do extra work to position it\n    // properly.\n    if (selectText.length == 0) {\n      parent = this.findDeepestContainer_(parent);\n    }\n\n    this.parentNode_ = parent;\n  }\n\n  return this.parentNode_;\n};\n\n\n/**\n * Helper method to find the deepest parent for this range, starting\n * the search from `node`, which must contain the range.\n * @param {Node} node The node to start the search from.\n * @return {Node} The deepest parent for this range.\n * @private\n */\ngoog.dom.browserrange.IeRange.prototype.findDeepestContainer_ = function(node) {\n  var childNodes = node.childNodes;\n  for (var i = 0, len = childNodes.length; i < len; i++) {\n    var child = childNodes[i];\n\n    if (goog.dom.browserrange.canContainRangeEndpoint(child)) {\n      var childRange =\n          goog.dom.browserrange.IeRange.getBrowserRangeForNode_(child);\n      var start = goog.dom.RangeEndpoint.START;\n      var end = goog.dom.RangeEndpoint.END;\n\n      // There are two types of erratic nodes where the range over node has\n      // different htmlText than the node's outerHTML.\n      // Case 1 - A node with magic &nbsp; child. In this case :\n      //    nodeRange.htmlText shows &nbsp; ('<p>&nbsp;</p>), while\n      //    node.outerHTML doesn't show the magic node (<p></p>).\n      // Case 2 - Empty span. In this case :\n      //    node.outerHTML shows '<span></span>'\n      //    node.htmlText is just empty string ''.\n      var isChildRangeErratic = (childRange.htmlText != child.outerHTML);\n\n      // Moreover the inRange comparison fails only when the\n      var isNativeInRangeErratic = this.isCollapsed() && isChildRangeErratic;\n\n      // In case 2 mentioned above, childRange is also collapsed. So we need to\n      // compare start of this range with both start and end of child range.\n      var inChildRange = isNativeInRangeErratic ?\n          (this.compareBrowserRangeEndpoints(childRange, start, start) >= 0 &&\n           this.compareBrowserRangeEndpoints(childRange, start, end) <= 0) :\n          this.range_.inRange(childRange);\n      if (inChildRange) {\n        return this.findDeepestContainer_(child);\n      }\n    }\n  }\n\n  return node;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.getStartNode = function() {\n  if (!this.startNode_) {\n    this.startNode_ = this.getEndpointNode_(goog.dom.RangeEndpoint.START);\n    if (this.isCollapsed()) {\n      this.endNode_ = this.startNode_;\n    }\n  }\n  return this.startNode_;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.getStartOffset = function() {\n  if (this.startOffset_ < 0) {\n    this.startOffset_ = this.getOffset_(goog.dom.RangeEndpoint.START);\n    if (this.isCollapsed()) {\n      this.endOffset_ = this.startOffset_;\n    }\n  }\n  return this.startOffset_;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.getEndNode = function() {\n  if (this.isCollapsed()) {\n    return this.getStartNode();\n  }\n  if (!this.endNode_) {\n    this.endNode_ = this.getEndpointNode_(goog.dom.RangeEndpoint.END);\n  }\n  return this.endNode_;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.getEndOffset = function() {\n  if (this.isCollapsed()) {\n    return this.getStartOffset();\n  }\n  if (this.endOffset_ < 0) {\n    this.endOffset_ = this.getOffset_(goog.dom.RangeEndpoint.END);\n    if (this.isCollapsed()) {\n      this.startOffset_ = this.endOffset_;\n    }\n  }\n  return this.endOffset_;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.compareBrowserRangeEndpoints = function(\n    range, thisEndpoint, otherEndpoint) {\n  return this.range_.compareEndPoints(\n      (thisEndpoint == goog.dom.RangeEndpoint.START ? 'Start' : 'End') + 'To' +\n          (otherEndpoint == goog.dom.RangeEndpoint.START ? 'Start' : 'End'),\n      range);\n};\n\n\n/**\n * Recurses to find the correct node for the given endpoint.\n * @param {goog.dom.RangeEndpoint} endpoint The endpoint to get the node for.\n * @param {Node=} opt_node Optional node to start the search from.\n * @return {Node} The deepest node containing the endpoint.\n * @private\n */\ngoog.dom.browserrange.IeRange.prototype.getEndpointNode_ = function(\n    endpoint, opt_node) {\n\n  /** @type {Node} */\n  var node = opt_node || this.getContainer();\n\n  // If we're at a leaf in the DOM, we're done.\n  if (!node || !node.firstChild) {\n    return node;\n  }\n\n  var start = goog.dom.RangeEndpoint.START, end = goog.dom.RangeEndpoint.END;\n  var isStartEndpoint = endpoint == start;\n\n  // Find the first/last child that overlaps the selection.\n  // NOTE(user) : One of the children can be the magic &nbsp; node. This\n  // node will have only nodeType property as valid and accessible. All other\n  // dom related properties like ownerDocument, parentNode, nextSibling etc\n  // cause error when accessed. Therefore use the for-loop on childNodes to\n  // iterate.\n  for (var j = 0, length = node.childNodes.length; j < length; j++) {\n    var i = isStartEndpoint ? j : length - j - 1;\n    var child = node.childNodes[i];\n    var childRange;\n    try {\n      childRange = goog.dom.browserrange.createRangeFromNodeContents(child);\n    } catch (e) {\n      // If the child is the magic &nbsp; node, then the above will throw\n      // error. The magic node exists only when editing using keyboard, so can\n      // not add any unit test.\n      continue;\n    }\n    var ieRange = childRange.getBrowserRange();\n\n    // Case 1 : Finding end points when this range is collapsed.\n    // Note that in case of collapsed range, getEnd{Node,Offset} call\n    // getStart{Node,Offset}.\n    if (this.isCollapsed()) {\n      // Handle situations where caret is not in a text node. In such cases,\n      // the adjacent child won't be a valid range endpoint container.\n      if (!goog.dom.browserrange.canContainRangeEndpoint(child)) {\n        // The following handles a scenario like <div><BR>[caret]<BR></div>,\n        // where point should be (div, 1).\n        if (this.compareBrowserRangeEndpoints(ieRange, start, start) == 0) {\n          this.startOffset_ = this.endOffset_ = i;\n          return node;\n        }\n      } else if (childRange.containsRange(this)) {\n        // For collapsed range, we should invert the containsRange check with\n        // childRange.\n        return this.getEndpointNode_(endpoint, child);\n      }\n\n      // Case 2 - The first child encountered to have overlap this range is\n      // contained entirely in this range.\n    } else if (this.containsRange(childRange)) {\n      // If it is an element which can not be a range endpoint container, the\n      // current child offset can be used to deduce the endpoint offset.\n      if (!goog.dom.browserrange.canContainRangeEndpoint(child)) {\n        // Container can't be any deeper, so current node is the container.\n        if (isStartEndpoint) {\n          this.startOffset_ = i;\n        } else {\n          this.endOffset_ = i + 1;\n        }\n        return node;\n      }\n\n      // If child can contain range endpoints, recurse inside this child.\n      return this.getEndpointNode_(endpoint, child);\n\n      // Case 3 - Partial non-adjacency overlap.\n    } else if (\n        this.compareBrowserRangeEndpoints(ieRange, start, end) < 0 &&\n        this.compareBrowserRangeEndpoints(ieRange, end, start) > 0) {\n      // If this child overlaps the selection partially, recurse down to find\n      // the first/last child the next level down that overlaps the selection\n      // completely. We do not consider edge-adjacency (== 0) as overlap.\n      return this.getEndpointNode_(endpoint, child);\n    }\n  }\n\n  // None of the children of this node overlapped the selection, that means\n  // the selection starts/ends in this node directly.\n  return node;\n};\n\n\n/**\n * Compares one endpoint of this range with the endpoint of a node.\n * For internal methods, we should prefer this method to containsNode.\n * containsNode has a lot of false negatives when we're dealing with\n * {@code <br>} tags.\n *\n * @param {Node} node The node to compare against.\n * @param {goog.dom.RangeEndpoint} thisEndpoint The endpoint of this range\n *     to compare with.\n * @param {goog.dom.RangeEndpoint} otherEndpoint The endpoint of the node\n *     to compare with.\n * @return {number} 0 if the endpoints are equal, negative if this range\n *     endpoint comes before the other node endpoint, and positive otherwise.\n * @private\n */\ngoog.dom.browserrange.IeRange.prototype.compareNodeEndpoints_ = function(\n    node, thisEndpoint, otherEndpoint) {\n  /** @suppress {missingRequire} Circular dep with browserrange */\n  return this.range_.compareEndPoints(\n      (thisEndpoint == goog.dom.RangeEndpoint.START ? 'Start' : 'End') + 'To' +\n          (otherEndpoint == goog.dom.RangeEndpoint.START ? 'Start' : 'End'),\n      goog.dom.browserrange.createRangeFromNodeContents(node)\n          .getBrowserRange());\n};\n\n\n/**\n * Returns the offset into the start/end container.\n * @param {goog.dom.RangeEndpoint} endpoint The endpoint to get the offset for.\n * @param {Node=} opt_container The container to get the offset relative to.\n *     Defaults to the value returned by getStartNode/getEndNode.\n * @return {number} The offset.\n * @private\n */\ngoog.dom.browserrange.IeRange.prototype.getOffset_ = function(\n    endpoint, opt_container) {\n  var isStartEndpoint = endpoint == goog.dom.RangeEndpoint.START;\n  var container = opt_container ||\n      (isStartEndpoint ? this.getStartNode() : this.getEndNode());\n\n  if (container.nodeType == goog.dom.NodeType.ELEMENT) {\n    // Find the first/last child that overlaps the selection\n    var children = container.childNodes;\n    var len = children.length;\n    var edge = isStartEndpoint ? 0 : len - 1;\n    var sign = isStartEndpoint ? 1 : -1;\n\n    // We find the index in the child array of the endpoint of the selection.\n    for (var i = edge; i >= 0 && i < len; i += sign) {\n      var child = children[i];\n      // Ignore the child nodes, which could be end point containers.\n      /** @suppress {missingRequire} Circular dep with browserrange */\n      if (goog.dom.browserrange.canContainRangeEndpoint(child)) {\n        continue;\n      }\n      // Stop looping when we reach the edge of the selection.\n      var endPointCompare =\n          this.compareNodeEndpoints_(child, endpoint, endpoint);\n      if (endPointCompare == 0) {\n        return isStartEndpoint ? i : i + 1;\n      }\n    }\n\n    // When starting from the end in an empty container, we erroneously return\n    // -1: fix this to return 0.\n    return i == -1 ? 0 : i;\n  } else {\n    // Get a temporary range object.\n    var range = this.range_.duplicate();\n\n    // Create a range that selects the entire container.\n    var nodeRange =\n        goog.dom.browserrange.IeRange.getBrowserRangeForNode_(container);\n\n    // Now, intersect our range with the container range - this should give us\n    // the part of our selection that is in the container.\n    range.setEndPoint(isStartEndpoint ? 'EndToEnd' : 'StartToStart', nodeRange);\n\n    var rangeLength = range.text.length;\n    return isStartEndpoint ? container.length - rangeLength : rangeLength;\n  }\n};\n\n\n/**\n * Returns the text of the given node.  Uses IE specific properties.\n * @param {Node} node The node to retrieve the text of.\n * @return {string} The node's text.\n * @private\n */\ngoog.dom.browserrange.IeRange.getNodeText_ = function(node) {\n  return node.nodeType == goog.dom.NodeType.TEXT ? node.nodeValue :\n                                                   node.innerText;\n};\n\n\n/**\n * Tests whether this range is valid (i.e. whether its endpoints are still in\n * the document).  A range becomes invalid when, after this object was created,\n * either one or both of its endpoints are removed from the document.  Use of\n * an invalid range can lead to runtime errors, particularly in IE.\n * @return {boolean} Whether the range is valid.\n */\ngoog.dom.browserrange.IeRange.prototype.isRangeInDocument = function() {\n  var range = this.doc_.body.createTextRange();\n  range.moveToElementText(this.doc_.body);\n\n  return this.containsRange(\n      new goog.dom.browserrange.IeRange(range, this.doc_), true);\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.isCollapsed = function() {\n  // Note(user) : The earlier implementation used (range.text == ''), but this\n  // fails when (range.htmlText == '<br>')\n  // Alternative: this.range_.htmlText == '';\n  return this.range_.compareEndPoints('StartToEnd', this.range_) == 0;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.getText = function() {\n  return this.range_.text;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.getValidHtml = function() {\n  return this.range_.htmlText;\n};\n\n\n// SELECTION MODIFICATION\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.select = function(opt_reverse) {\n  // IE doesn't support programmatic reversed selections.\n  this.range_.select();\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.removeContents = function() {\n  // NOTE: Sometimes htmlText is non-empty, but the range is actually empty.\n  // TODO(gboyer): The htmlText check is probably unnecessary, but I left it in\n  // for paranoia.\n  if (!this.isCollapsed() && this.range_.htmlText) {\n    // Store some before-removal state.\n    var startNode = this.getStartNode();\n    var endNode = this.getEndNode();\n    var oldText = this.range_.text;\n\n    // IE sometimes deletes nodes unrelated to the selection.  This trick fixes\n    // that problem most of the time.  Even though it looks like a no-op, it is\n    // somehow changing IE's internal state such that empty unrelated nodes are\n    // no longer deleted.\n    var clone = this.range_.duplicate();\n    clone.moveStart('character', 1);\n    clone.moveStart('character', -1);\n\n    // However, sometimes moving the start back and forth ends up changing the\n    // range.\n    // TODO(gboyer): This condition used to happen for empty ranges, but (1)\n    // never worked, and (2) the isCollapsed call should protect against empty\n    // ranges better than before.  However, this is left for paranoia.\n    if (clone.text == oldText) {\n      this.range_ = clone;\n    }\n\n    // Use the browser's native deletion code.\n    this.range_.text = '';\n    this.clearCachedValues_();\n\n    // Unfortunately, when deleting a portion of a single text node, IE creates\n    // an extra text node unlike other browsers which just change the text in\n    // the node.  We normalize for that behavior here, making IE behave like all\n    // the other browsers.\n    var newStartNode = this.getStartNode();\n    var newStartOffset = this.getStartOffset();\n\n    try {\n      var sibling = startNode.nextSibling;\n      if (startNode == endNode && startNode.parentNode &&\n          startNode.nodeType == goog.dom.NodeType.TEXT && sibling &&\n          sibling.nodeType == goog.dom.NodeType.TEXT) {\n        startNode.nodeValue += sibling.nodeValue;\n        goog.dom.removeNode(sibling);\n\n        // Make sure to reselect the appropriate position.\n        this.range_ =\n            goog.dom.browserrange.IeRange.getBrowserRangeForNode_(newStartNode);\n        this.range_.move('character', newStartOffset);\n        this.clearCachedValues_();\n      }\n    } catch (e) {\n      // IE throws errors on orphaned nodes.\n    }\n  }\n};\n\n\n/**\n * @param {TextRange} range The range to get a dom helper for.\n * @return {!goog.dom.DomHelper} A dom helper for the document the range\n *     resides in.\n * @private\n */\ngoog.dom.browserrange.IeRange.getDomHelper_ = function(range) {\n  return goog.dom.getDomHelper(range.parentElement());\n};\n\n\n/**\n * Pastes the given element into the given range, returning the resulting\n * element.\n * @param {TextRange} range The range to paste into.\n * @param {Element} element The node to insert a copy of.\n * @param {goog.dom.DomHelper=} opt_domHelper DOM helper object for the document\n *     the range resides in.\n * @return {Element} The resulting copy of element.\n * @private\n */\ngoog.dom.browserrange.IeRange.pasteElement_ = function(\n    range, element, opt_domHelper) {\n  opt_domHelper =\n      opt_domHelper || goog.dom.browserrange.IeRange.getDomHelper_(range);\n\n  // Make sure the node has a unique id.\n  var id;\n  var originalId = id = element.id;\n  if (!id) {\n    id = element.id = goog.string.createUniqueString();\n  }\n\n  // Insert (a clone of) the node.\n  range.pasteHTML(element.outerHTML);\n\n  // Pasting the outerHTML of the modified element into the document creates\n  // a clone of the element argument.  We want to return a reference to the\n  // clone, not the original.  However we need to remove the temporary ID\n  // first.\n  element = opt_domHelper.getElement(id);\n\n  // If element is null here, we failed.\n  if (element) {\n    if (!originalId) {\n      element.removeAttribute('id');\n    }\n  }\n\n  return element;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.surroundContents = function(element) {\n  // Make sure the element is detached from the document.\n  goog.dom.removeNode(element);\n\n  // IE more or less guarantees that range.htmlText is well-formed & valid.\n  element.innerHTML = this.range_.htmlText;\n  element = goog.dom.browserrange.IeRange.pasteElement_(this.range_, element);\n\n  // If element is null here, we failed.\n  if (element) {\n    this.range_.moveToElementText(element);\n  }\n\n  this.clearCachedValues_();\n\n  return element;\n};\n\n\n/**\n * Internal handler for inserting a node.\n * @param {TextRange} clone A clone of this range's browser range object.\n * @param {Node} node The node to insert.\n * @param {boolean} before Whether to insert the node before or after the range.\n * @param {goog.dom.DomHelper=} opt_domHelper The dom helper to use.\n * @return {Node} The resulting copy of node.\n * @private\n */\ngoog.dom.browserrange.IeRange.insertNode_ = function(\n    clone, node, before, opt_domHelper) {\n  // Get a DOM helper.\n  opt_domHelper =\n      opt_domHelper || goog.dom.browserrange.IeRange.getDomHelper_(clone);\n\n  // If it's not an element, wrap it in one.\n  var isNonElement;\n  if (node.nodeType != goog.dom.NodeType.ELEMENT) {\n    isNonElement = true;\n    node = opt_domHelper.createDom(goog.dom.TagName.DIV, null, node);\n  }\n\n  clone.collapse(before);\n  node = goog.dom.browserrange.IeRange.pasteElement_(\n      clone,\n      /** @type {!Element} */ (node), opt_domHelper);\n\n  // If we didn't want an element, unwrap the element and return the node.\n  if (isNonElement) {\n    // pasteElement_() may have returned a copy of the wrapper div, and the\n    // node it wraps could also be a new copy. So we must extract that new\n    // node from the new wrapper.\n    var newNonElement = node.firstChild;\n    opt_domHelper.flattenElement(node);\n    node = newNonElement;\n  }\n\n  return node;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.insertNode = function(node, before) {\n  var output = goog.dom.browserrange.IeRange.insertNode_(\n      this.range_.duplicate(), node, before);\n  this.clearCachedValues_();\n  return output;\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.surroundWithNodes = function(\n    startNode, endNode) {\n  var clone1 = this.range_.duplicate();\n  var clone2 = this.range_.duplicate();\n  goog.dom.browserrange.IeRange.insertNode_(clone1, startNode, true);\n  goog.dom.browserrange.IeRange.insertNode_(clone2, endNode, false);\n\n  this.clearCachedValues_();\n};\n\n\n/** @override */\ngoog.dom.browserrange.IeRange.prototype.collapse = function(toStart) {\n  this.range_.collapse(toStart);\n\n  if (toStart) {\n    this.endNode_ = this.startNode_;\n    this.endOffset_ = this.startOffset_;\n  } else {\n    this.startNode_ = this.endNode_;\n    this.startOffset_ = this.endOffset_;\n  }\n};\n"],
"names":["goog","provide","require","dom","browserrange","IeRange","goog.dom.browserrange.IeRange","range","doc","parentNode_","startNode_","endNode_","startOffset_","endOffset_","range_","doc_","inherits","AbstractRange","logger_","log","getLogger","getBrowserRangeForNode_","goog.dom.browserrange.IeRange.getBrowserRangeForNode_","node","nodeRange","getOwnerDocument","body","createTextRange","nodeType","NodeType","ELEMENT","moveToElementText","canContainRangeEndpoint","childNodes","length","collapse","offset","sibling","previousSibling","TEXT","parentNode","move","moveEnd","getBrowserRangeForNodes_","goog.dom.browserrange.IeRange.getBrowserRangeForNodes_","startNode","startOffset","endNode","endOffset","child","error","lastChild","leftRange","rightRange","setEndPoint","createFromNodeContents","goog.dom.browserrange.IeRange.createFromNodeContents","array","indexOf","tempNode","leaf","firstChild","createFromNodes","goog.dom.browserrange.IeRange.createFromNodes","prototype","clone","goog.dom.browserrange.IeRange.prototype.clone","duplicate","getBrowserRange","goog.dom.browserrange.IeRange.prototype.getBrowserRange","clearCachedValues_","goog.dom.browserrange.IeRange.prototype.clearCachedValues_","getContainer","goog.dom.browserrange.IeRange.prototype.getContainer","selectText","text","rightTrimmedSelectText","replace","numSpacesAtEnd","parent","parentElement","htmlText","htmlTextLen","string","stripNewlines","isCollapsed","outerHTML","innerText","getNodeText_","findDeepestContainer_","goog.dom.browserrange.IeRange.prototype.findDeepestContainer_","i","len","childRange","start","RangeEndpoint","START","end","END","isChildRangeErratic","isNativeInRangeErratic","inChildRange","compareBrowserRangeEndpoints","inRange","getStartNode","goog.dom.browserrange.IeRange.prototype.getStartNode","getEndpointNode_","getStartOffset","goog.dom.browserrange.IeRange.prototype.getStartOffset","getOffset_","getEndNode","goog.dom.browserrange.IeRange.prototype.getEndNode","getEndOffset","goog.dom.browserrange.IeRange.prototype.getEndOffset","goog.dom.browserrange.IeRange.prototype.compareBrowserRangeEndpoints","thisEndpoint","otherEndpoint","compareEndPoints","goog.dom.browserrange.IeRange.prototype.getEndpointNode_","endpoint","opt_node","isStartEndpoint","j","createRangeFromNodeContents","e","ieRange","containsRange","compareNodeEndpoints_","goog.dom.browserrange.IeRange.prototype.compareNodeEndpoints_","goog.dom.browserrange.IeRange.prototype.getOffset_","opt_container","container","children","edge","sign","endPointCompare","rangeLength","goog.dom.browserrange.IeRange.getNodeText_","nodeValue","isRangeInDocument","goog.dom.browserrange.IeRange.prototype.isRangeInDocument","goog.dom.browserrange.IeRange.prototype.isCollapsed","getText","goog.dom.browserrange.IeRange.prototype.getText","getValidHtml","goog.dom.browserrange.IeRange.prototype.getValidHtml","select","goog.dom.browserrange.IeRange.prototype.select","opt_reverse","removeContents","goog.dom.browserrange.IeRange.prototype.removeContents","oldText","moveStart","newStartNode","newStartOffset","nextSibling","removeNode","getDomHelper_","goog.dom.browserrange.IeRange.getDomHelper_","getDomHelper","pasteElement_","goog.dom.browserrange.IeRange.pasteElement_","element","opt_domHelper","id","originalId","createUniqueString","pasteHTML","getElement","removeAttribute","surroundContents","goog.dom.browserrange.IeRange.prototype.surroundContents","innerHTML","insertNode_","goog.dom.browserrange.IeRange.insertNode_","before","isNonElement","createDom","TagName","DIV","newNonElement","flattenElement","insertNode","goog.dom.browserrange.IeRange.prototype.insertNode","output","surroundWithNodes","goog.dom.browserrange.IeRange.prototype.surroundWithNodes","clone1","clone2","goog.dom.browserrange.IeRange.prototype.collapse","toStart"]
}

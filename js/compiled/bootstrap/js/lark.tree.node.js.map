{"version":3,"sources":["lark/tree/node.cljc"],"mappings":";;;;AAOA;;;AAAA,AAAMA,AAEHC;AAFH,AAGE,AAAA,AAAAC,AAAA,AAAA,AAAAA,AAAA,AAC6B,AAAA,AAAOD,AAAAA;;AAEtC,AAAA,AAAME,AACHF;AADH,AAEE,AAACG,AAAmB,AAAOH;;AAE7B,AAAA,AAAMI,AACHJ;AADH,AAEE,AAAA,AAACK,AAAW,AAAOL;;AAErB;;;AAAKM,AAEH,AAACC,AAAW,AAACC,AAAWT,AACZ,AAACS,AAAWN;AAE1B,AAAA,AAAMO,AAAgBT;AAAtB,AACE,AAAMU,AAAI,AAAOV;AAAjB,AACE,AAAK,AAAK,AAAA,AAAAC,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAkDS,AAAAA,AAAAA,AACvD,AAAA,AAAAT,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAA,AAAA,AAUoDS,AAAAA,AAAAA,AAAAA,AAAAA,AAAAA,AAAAA,AAAAA,AAAAA,AAAAA,AAAAA;;AAE7D,AAAKC,AAAsB,AAACH,AAAWC;AAEvC;;;AAAA,AAAMG,AAEHZ;AAFH,AAGE,AAAMA;AAAN,AACE,AAACa,AAAUC,AAAS,AAAOd;;AAD7B;;;AAGF,AAAA,AAAMe,AAAOf;AAAb,AACE,AAAMA;AAAN,AACE,AAACgB,AAAIF,AAAS,AAAOd;;AADvB;;;AAGF;;;AAAA,AAAMiB,AAEHC;AAFH,AAGE,AAACC,AACAR,AACA,AAAAS;AAAA,AAAA,AAAAC,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAA,AAAAL,AAAAK,AAAA,AAAaI;AAAb,AAAyB,AAAU,AAACC,AAAOD;AAAlB;;AAAA,AAA4BA;;AACrD,AAAKzB,AAAKyB;AAAV,AAAoB,AAAA,AAACE,AAAM3B,AAAeyB;AAC1CP","names":["lark.tree.node/comment?","node","cljs.core/keyword-identical?","lark.tree.node/whitespace?","lark.tree.reader/whitespace-tag?","lark.tree.node/newline?","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","lark.tree.node/sexp?","cljs.core.every_pred.cljs$core$IFn$_invoke$arity$2","cljs.core/complement","lark.tree.node/terminal-node?","tag","lark.tree.node/may-contain-children?","lark.tree.node/has-edges?","cljs.core/contains?","lark.tree.reader/edges","lark.tree.node/edges","cljs.core.get.cljs$core$IFn$_invoke$arity$2","lark.tree.node/ast-zip","ast","fast-zip.core/zipper","p__64131","map__64132","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","children","cljs.core/empty?","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3"],"sourcesContent":["(ns lark.tree.node\n  (:require [lark.tree.reader :as rd]\n            [fast-zip.core :as z]\n   #?(:clj\n            [lark.tree.util :refer [contains-identical-keyword?]]))\n  #?(:cljs (:require-macros [lark.tree.util :refer [contains-identical-keyword?]])))\n\n(defn comment?\n  \"Returns true if node is a comment - either `;` or `#_` but not `(comment ...)`\"\n  [node]\n  (contains-identical-keyword? [:comment :uneval]\n                               (.-tag node)))\n\n(defn whitespace?\n  [node]\n  (rd/whitespace-tag? (.-tag node)))\n\n(defn newline?\n  [node]\n  (= :newline (.-tag node)))\n\n(def sexp?\n  \"Returns false if node does not have corresponding s-expression (eg. comments and whitespace)\"\n  (every-pred (complement comment?)\n              (complement whitespace?)))\n\n(defn terminal-node? [node]\n  (let [tag (.-tag node)]\n    (and (not (contains-identical-keyword? [:list :vector :map] tag))\n         (contains-identical-keyword? [:space\n                                       :symbol\n                                       :keyword\n                                       :token\n                                       :string\n                                       :number\n                                       :newline\n                                       :comma\n                                       :comment\n                                       :comment-block\n                                       :unmatched-delimiter] tag))))\n\n(def may-contain-children? (complement terminal-node?))\n\n(defn has-edges?\n  \"Returns true if node has 'edges' that mark boundaries. See unwrap/edges for details.\"\n  [node]\n  (when node\n    (contains? rd/edges (.-tag node))))\n\n(defn edges [node]\n  (when node\n    (get rd/edges (.-tag node))))\n\n(defn ast-zip\n  \"Given AST, returns zipper\"\n  [ast]\n  (z/zipper\n   may-contain-children?\n   (fn [{:keys [children]}] (when-not (empty? children) children))\n   (fn [node children] (assoc node :children children))\n   ast))"]}
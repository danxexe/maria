{
"version":3,
"file":"goog.dom.tagiterator.js",
"lineCount":166,
"mappings":"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",
"sources":["goog/dom/tagiterator.js"],
"sourcesContent":["// Copyright 2008 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Iterator subclass for DOM tree traversal.\n *\n * @author robbyw@google.com (Robby Walker)\n */\n\ngoog.provide('goog.dom.TagIterator');\ngoog.provide('goog.dom.TagWalkType');\n\ngoog.require('goog.dom');\ngoog.require('goog.dom.NodeType');\ngoog.require('goog.iter.Iterator');\ngoog.require('goog.iter.StopIteration');\n\n\n/**\n * There are three types of token:\n *  <ol>\n *    <li>`START_TAG` - The beginning of a tag.\n *    <li>`OTHER` - Any non-element node position.\n *    <li>`END_TAG` - The end of a tag.\n *  </ol>\n * Users of this enumeration can rely on {@code START_TAG + END_TAG = 0} and\n * that {@code OTHER = 0}.\n *\n * @enum {number}\n */\ngoog.dom.TagWalkType = {\n  START_TAG: 1,\n  OTHER: 0,\n  END_TAG: -1\n};\n\n\n\n/**\n * A DOM tree traversal iterator.\n *\n * Starting with the given node, the iterator walks the DOM in order, reporting\n * events for the start and end of Elements, and the presence of text nodes. For\n * example:\n *\n * <pre>\n * &lt;div&gt;1&lt;span&gt;2&lt;/span&gt;3&lt;/div&gt;\n * </pre>\n *\n * Will return the following nodes:\n *\n * <code>[div, 1, span, 2, span, 3, div]</code>\n *\n * With the following states:\n *\n * <code>[START, OTHER, START, OTHER, END, OTHER, END]</code>\n *\n * And the following depths\n *\n * <code>[1, 1, 2, 2, 1, 1, 0]</code>\n *\n * Imagining <code>|</code> represents iterator position, the traversal stops at\n * each of the following locations:\n *\n * <pre>\n * &lt;div&gt;|1|&lt;span&gt;|2|&lt;/span&gt;|3|&lt;/div&gt;|\n * </pre>\n *\n * The iterator can also be used in reverse mode, which will return the nodes\n * and states in the opposite order.  The depths will be slightly different\n * since, like in normal mode, the depth is computed *after* the given node.\n *\n * Lastly, it is possible to create an iterator that is unconstrained, meaning\n * that it will continue iterating until the end of the document instead of\n * until exiting the start node.\n *\n * @param {Node=} opt_node The start node.  If unspecified or null, defaults to\n *     an empty iterator.\n * @param {boolean=} opt_reversed Whether to traverse the tree in reverse.\n * @param {boolean=} opt_unconstrained Whether the iterator is not constrained\n *     to the starting node and its children.\n * @param {goog.dom.TagWalkType?=} opt_tagType The type of the position.\n *     Defaults to the start of the given node for forward iterators, and\n *     the end of the node for reverse iterators.\n * @param {number=} opt_depth The starting tree depth.\n * @constructor\n * @extends {goog.iter.Iterator<Node>}\n */\ngoog.dom.TagIterator = function(\n    opt_node, opt_reversed, opt_unconstrained, opt_tagType, opt_depth) {\n  /**\n   * Whether the node iterator is moving in reverse.\n   * @type {boolean}\n   */\n  this.reversed = !!opt_reversed;\n\n  /**\n   * The node this position is located on.\n   * @type {?Node}\n   */\n  this.node = null;\n\n  /**\n   * The type of this position.\n   * @type {goog.dom.TagWalkType}\n   */\n  this.tagType = goog.dom.TagWalkType.OTHER;\n\n  /**\n   * The tree depth of this position relative to where the iterator started.\n   * The depth is considered to be the tree depth just past the current node,\n   * so if an iterator is at position\n   * <pre>\n   *     <div>|</div>\n   * </pre>\n   * (i.e. the node is the div and the type is START_TAG) its depth will be 1.\n   * @type {number}\n   */\n  this.depth;\n\n  /**\n   * Whether iteration has started.\n   * @private {boolean}\n   */\n  this.started_ = false;\n\n  /**\n   * Whether the iterator is constrained to the starting node and its children.\n   * @type {boolean}\n   */\n  this.constrained = !opt_unconstrained;\n\n  if (opt_node) {\n    this.setPosition(opt_node, opt_tagType);\n  }\n  this.depth = opt_depth != undefined ? opt_depth : this.tagType || 0;\n  if (this.reversed) {\n    this.depth *= -1;\n  }\n};\ngoog.inherits(goog.dom.TagIterator, goog.iter.Iterator);\n\n\n/**\n * Set the position of the iterator.  Overwrite the tree node and the position\n * type which can be one of the {@link goog.dom.TagWalkType} token types.\n * Only overwrites the tree depth when the parameter is specified.\n * @param {Node} node The node to set the position to.\n * @param {goog.dom.TagWalkType?=} opt_tagType The type of the position\n *     Defaults to the start of the given node.\n * @param {number=} opt_depth The tree depth.\n */\ngoog.dom.TagIterator.prototype.setPosition = function(\n    node, opt_tagType, opt_depth) {\n  this.node = node;\n\n  if (node) {\n    if (goog.isNumber(opt_tagType)) {\n      this.tagType = opt_tagType;\n    } else {\n      // Auto-determine the proper type\n      this.tagType = this.node.nodeType != goog.dom.NodeType.ELEMENT ?\n          goog.dom.TagWalkType.OTHER :\n          this.reversed ? goog.dom.TagWalkType.END_TAG :\n                          goog.dom.TagWalkType.START_TAG;\n    }\n  }\n\n  if (goog.isNumber(opt_depth)) {\n    this.depth = opt_depth;\n  }\n};\n\n\n/**\n * Replace this iterator's values with values from another. The two iterators\n * must be of the same type.\n * @param {goog.dom.TagIterator} other The iterator to copy.\n * @protected\n */\ngoog.dom.TagIterator.prototype.copyFrom = function(other) {\n  this.node = other.node;\n  this.tagType = other.tagType;\n  this.depth = other.depth;\n  this.reversed = other.reversed;\n  this.constrained = other.constrained;\n};\n\n\n/**\n * @return {!goog.dom.TagIterator} A copy of this iterator.\n */\ngoog.dom.TagIterator.prototype.clone = function() {\n  return new goog.dom.TagIterator(\n      this.node, this.reversed, !this.constrained, this.tagType, this.depth);\n};\n\n\n/**\n * Skip the current tag.\n */\ngoog.dom.TagIterator.prototype.skipTag = function() {\n  var check = this.reversed ? goog.dom.TagWalkType.END_TAG :\n                              goog.dom.TagWalkType.START_TAG;\n  if (this.tagType == check) {\n    this.tagType = /** @type {goog.dom.TagWalkType} */ (check * -1);\n    this.depth += this.tagType * (this.reversed ? -1 : 1);\n  }\n};\n\n\n/**\n * Restart the current tag.\n */\ngoog.dom.TagIterator.prototype.restartTag = function() {\n  var check = this.reversed ? goog.dom.TagWalkType.START_TAG :\n                              goog.dom.TagWalkType.END_TAG;\n  if (this.tagType == check) {\n    this.tagType = /** @type {goog.dom.TagWalkType} */ (check * -1);\n    this.depth += this.tagType * (this.reversed ? -1 : 1);\n  }\n};\n\n\n/**\n * Move to the next position in the DOM tree.\n * @return {Node} Returns the next node, or throws a goog.iter.StopIteration\n *     exception if the end of the iterator's range has been reached.\n * @override\n */\ngoog.dom.TagIterator.prototype.next = function() {\n  var node;\n\n  if (this.started_) {\n    if (!this.node || this.constrained && this.depth == 0) {\n      throw goog.iter.StopIteration;\n    }\n    node = this.node;\n\n    var startType = this.reversed ? goog.dom.TagWalkType.END_TAG :\n                                    goog.dom.TagWalkType.START_TAG;\n\n    if (this.tagType == startType) {\n      // If we have entered the tag, test if there are any children to move to.\n      var child = this.reversed ? node.lastChild : node.firstChild;\n      if (child) {\n        this.setPosition(child);\n      } else {\n        // If not, move on to exiting this tag.\n        this.setPosition(\n            node,\n            /** @type {goog.dom.TagWalkType} */ (startType * -1));\n      }\n    } else {\n      var sibling = this.reversed ? node.previousSibling : node.nextSibling;\n      if (sibling) {\n        // Try to move to the next node.\n        this.setPosition(sibling);\n      } else {\n        // If no such node exists, exit our parent.\n        this.setPosition(\n            node.parentNode,\n            /** @type {goog.dom.TagWalkType} */ (startType * -1));\n      }\n    }\n\n    this.depth += this.tagType * (this.reversed ? -1 : 1);\n  } else {\n    this.started_ = true;\n  }\n\n  // Check the new position for being last, and return it if it's not.\n  node = this.node;\n  if (!this.node) {\n    throw goog.iter.StopIteration;\n  }\n  return node;\n};\n\n\n/**\n * @return {boolean} Whether next has ever been called on this iterator.\n * @protected\n */\ngoog.dom.TagIterator.prototype.isStarted = function() {\n  return this.started_;\n};\n\n\n/**\n * @return {boolean} Whether this iterator's position is a start tag position.\n */\ngoog.dom.TagIterator.prototype.isStartTag = function() {\n  return this.tagType == goog.dom.TagWalkType.START_TAG;\n};\n\n\n/**\n * @return {boolean} Whether this iterator's position is an end tag position.\n */\ngoog.dom.TagIterator.prototype.isEndTag = function() {\n  return this.tagType == goog.dom.TagWalkType.END_TAG;\n};\n\n\n/**\n * @return {boolean} Whether this iterator's position is not at an element node.\n */\ngoog.dom.TagIterator.prototype.isNonElement = function() {\n  return this.tagType == goog.dom.TagWalkType.OTHER;\n};\n\n\n/**\n * Test if two iterators are at the same position - i.e. if the node and tagType\n * is the same.  This will still return true if the two iterators are moving in\n * opposite directions or have different constraints.\n * @param {goog.dom.TagIterator} other The iterator to compare to.\n * @return {boolean} Whether the two iterators are at the same position.\n */\ngoog.dom.TagIterator.prototype.equals = function(other) {\n  // Nodes must be equal, and we must either have reached the end of our tree\n  // or be at the same position.\n  return other.node == this.node &&\n      (!this.node || other.tagType == this.tagType);\n};\n\n\n/**\n * Replace the current node with the list of nodes. Reset the iterator so that\n * it visits the first of the nodes next.\n * @param {...Object} var_args A list of nodes to replace the current node with.\n *     If the first argument is array-like, it will be used, otherwise all the\n *     arguments are assumed to be nodes.\n */\ngoog.dom.TagIterator.prototype.splice = function(var_args) {\n  // Reset the iterator so that it iterates over the first replacement node in\n  // the arguments on the next iteration.\n  var node = this.node;\n  this.restartTag();\n  this.reversed = !this.reversed;\n  goog.dom.TagIterator.prototype.next.call(this);\n  this.reversed = !this.reversed;\n\n  // Replace the node with the arguments.\n  var arr = goog.isArrayLike(arguments[0]) ? arguments[0] : arguments;\n  for (var i = arr.length - 1; i >= 0; i--) {\n    goog.dom.insertSiblingAfter(arr[i], node);\n  }\n  goog.dom.removeNode(node);\n};\n"],
"names":["goog","provide","require","dom","TagWalkType","START_TAG","OTHER","END_TAG","TagIterator","goog.dom.TagIterator","opt_node","opt_reversed","opt_unconstrained","opt_tagType","opt_depth","reversed","node","tagType","depth","started_","constrained","setPosition","undefined","inherits","iter","Iterator","prototype","goog.dom.TagIterator.prototype.setPosition","isNumber","nodeType","NodeType","ELEMENT","copyFrom","goog.dom.TagIterator.prototype.copyFrom","other","clone","goog.dom.TagIterator.prototype.clone","skipTag","goog.dom.TagIterator.prototype.skipTag","check","restartTag","goog.dom.TagIterator.prototype.restartTag","next","goog.dom.TagIterator.prototype.next","StopIteration","startType","child","lastChild","firstChild","sibling","previousSibling","nextSibling","parentNode","isStarted","goog.dom.TagIterator.prototype.isStarted","isStartTag","goog.dom.TagIterator.prototype.isStartTag","isEndTag","goog.dom.TagIterator.prototype.isEndTag","isNonElement","goog.dom.TagIterator.prototype.isNonElement","equals","goog.dom.TagIterator.prototype.equals","splice","goog.dom.TagIterator.prototype.splice","var_args","call","arr","isArrayLike","arguments","i","length","insertSiblingAfter","removeNode"]
}

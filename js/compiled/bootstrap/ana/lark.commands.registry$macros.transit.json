["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","lark/commands/registry$macros.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",27],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$lark.commands.registry$macros","~:imports",null,"~:requires",["^ ","^<","^<","~$goog","^F"],"~:seen",["^A",[]],"~:shadow/js-access-global",["^A",["Error"]],"~:uses",null,"~:defs",["^ ","~$parse-opt-args",["^ ","~:protocol-inline",null,"^2",["^ ","^3","lark/commands/registry$macros.cljc","^4",3,"^5",7,"^6",3,"^7",21,"~:arglists",["~#list",["~$quote",["^N",[["~$preds","~$args"]]]]]],"^B","~$lark.commands.registry$macros/parse-opt-args","^3","lark/commands/registry$macros.cljc","^7",21,"~:method-params",["^N",[["^P","^Q"]]],"~:protocol-impl",null,"~:arglists-meta",["^N",[null,null]],"^5",1,"~:variadic?",false,"^4",3,"~:ret-tag","~$clj","^6",3,"~:max-fixed-arity",2,"~:fn-var",true,"^M",["^N",["^O",["^N",[["^P","^Q"]]]]]],"~$defcommand",["^ ","^L",null,"^2",["^ ","^3","lark/commands/registry$macros.cljc","^7",21,"~:top-fn",["^ ","^V",true,"~:fixed-arity",1,"^Y",1,"^S",["^N",[["^N",["~$command-name","^Q"]]]],"^M",["^N",[["^12","~$&","^Q"]]],"^U",["^N",[null]]],"^5",11,"^4",14,"~:macro",true,"^6",14,"^M",["^N",["^O",["^N",[["^12","~$&","^Q"]]]]],"~:doc","Defines a command. command-name should be a namespaced keyword, followed by the optional positional args:\n  - docstring\n  - options map, which may contain:\n      :bindings, a vector of keymaps to bind, each containing a keyset of the form 'Cmd-X'\n      :intercept-when, a predicate indicating whether the key binding should stopPropagation and preventDefault\n           (if not supplied, will stop the event when :exec-when is true)\n      :when, a predicate indicating whether the command is enabled for a given context\n  - a vector of arguments followed by body forms, for the command function.\n\n  If no arglist/body is provided, a passthrough function will be supplied, so that `defcommand`\n  can be used for documenting existing/built-in behaviour."],"^B","~$lark.commands.registry$macros/defcommand","^3","lark/commands/registry$macros.cljc","^7",21,"^10",["^ ","^V",true,"^11",1,"^Y",1,"^S",["^N",[["^N",["^12","^Q"]]]],"^M",["^N",[["^12","~$&","^Q"]]],"^U",["^N",[null]]],"^S",["^N",[["^N",["^12","^Q"]]]],"^T",null,"^11",1,"^U",["^N",[null]],"^5",1,"^V",true,"~:methods",[["^ ","^11",1,"^V",true,"~:tag",["^A",["~$seq","~$cljs.core/IList"]]]],"^4",14,"^13",true,"^W","~$any","^6",14,"^Y",1,"^Z",false,"^M",["^N",[["^12","~$&","^Q"]]],"^14","Defines a command. command-name should be a namespaced keyword, followed by the optional positional args:\n  - docstring\n  - options map, which may contain:\n      :bindings, a vector of keymaps to bind, each containing a keyset of the form 'Cmd-X'\n      :intercept-when, a predicate indicating whether the key binding should stopPropagation and preventDefault\n           (if not supplied, will stop the event when :exec-when is true)\n      :when, a predicate indicating whether the command is enabled for a given context\n  - a vector of arguments followed by body forms, for the command function.\n\n  If no arglist/body is provided, a passthrough function will be supplied, so that `defcommand`\n  can be used for documenting existing/built-in behaviour."]],"~:require-macros",["^ ","^<","^<"],"~:cljs.analyzer/constants",["^ ","^G",["^A",["~:exec-pred","~:intercept-pred","~:when*","~:when","~:bindings","^B","~:intercept-when","~:intercept-when*","~:command","~$cljs.core/constantly","~$lark.commands.registry/register!","~$cljs.core/fn","~:lark.commands/Pass","^14"]],"~:order",["^1A","^1@","^1B","^1C","^1?","^B","^14","^1=","^1>","^1E","^1D","^1G","^1H","^1F"]],"~:flags",["^ "],"~:js-deps",["^ "],"~:deps",["^F","^<"]]
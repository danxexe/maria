["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","lark/commands/registry$macros.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",27],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.core","~$cljs.core","~$clojure.spec.alpha","~$cljs.spec.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$lark.commands.registry$macros","~:imports",null,"~:requires",["^ ","^<","^<","~$goog","^F"],"~:seen",["^A",[]],"~:uses",null,"~:defs",["^ ","~$parse-opt-args",["^ ","~:protocol-inline",null,"^2",["^ ","^3","lark/commands/registry$macros.cljc","^4",3,"^5",7,"^6",3,"^7",21,"~:arglists",["~#list",["~$quote",["^M",[["~$preds","~$args"]]]]]],"^B","~$lark.commands.registry$macros/parse-opt-args","^3","lark/commands/registry$macros.cljc","^7",21,"~:method-params",["^M",[["^O","^P"]]],"~:protocol-impl",null,"~:arglists-meta",["^M",[null,null]],"^5",1,"~:variadic?",false,"^4",3,"~:ret-tag","~$clj","^6",3,"~:max-fixed-arity",2,"~:fn-var",true,"^L",["^M",["^N",["^M",[["^O","^P"]]]]]],"~$defcommand",["^ ","^K",null,"^2",["^ ","^3","lark/commands/registry$macros.cljc","^7",21,"~:top-fn",["^ ","^U",true,"~:fixed-arity",1,"^X",1,"^R",["^M",[["^M",["~$command-name","^P"]]]],"^L",["^M",[["^11","~$&","^P"]]],"^T",["^M",[null]]],"^5",11,"^4",14,"~:macro",true,"^6",14,"^L",["^M",["^N",["^M",[["^11","~$&","^P"]]]]],"~:doc","Defines a command. command-name should be a namespaced keyword, followed by the optional positional args:\n  - docstring\n  - options map, which may contain:\n      :bindings, a vector of keymaps to bind, each containing a keyset of the form 'Cmd-X'\n      :intercept-when, a predicate indicating whether the key binding should stopPropagation and preventDefault\n           (if not supplied, will stop the event when :exec-when is true)\n      :when, a predicate indicating whether the command is enabled for a given context\n  - a vector of arguments followed by body forms, for the command function.\n\n  If no arglist/body is provided, a passthrough function will be supplied, so that `defcommand`\n  can be used for documenting existing/built-in behaviour."],"^B","~$lark.commands.registry$macros/defcommand","^3","lark/commands/registry$macros.cljc","^7",21,"^[",["^ ","^U",true,"^10",1,"^X",1,"^R",["^M",[["^M",["^11","^P"]]]],"^L",["^M",[["^11","~$&","^P"]]],"^T",["^M",[null]]],"^R",["^M",[["^M",["^11","^P"]]]],"^S",null,"^10",1,"^T",["^M",[null]],"^5",1,"^U",true,"~:methods",[["^ ","^10",1,"^U",true,"~:tag",["^A",["~$seq","~$cljs.core/IList"]]]],"^4",14,"^12",true,"^V","~$any","^6",14,"^X",1,"^Y",false,"^L",["^M",[["^11","~$&","^P"]]],"^13","Defines a command. command-name should be a namespaced keyword, followed by the optional positional args:\n  - docstring\n  - options map, which may contain:\n      :bindings, a vector of keymaps to bind, each containing a keyset of the form 'Cmd-X'\n      :intercept-when, a predicate indicating whether the key binding should stopPropagation and preventDefault\n           (if not supplied, will stop the event when :exec-when is true)\n      :when, a predicate indicating whether the command is enabled for a given context\n  - a vector of arguments followed by body forms, for the command function.\n\n  If no arglist/body is provided, a passthrough function will be supplied, so that `defcommand`\n  can be used for documenting existing/built-in behaviour."]],"~:require-macros",["^ ","^<","^<"],"~:cljs.analyzer/constants",["^ ","^G",["^A",["~:exec-pred","~:intercept-pred","~:when*","~:when","~:bindings","^B","~:intercept-when","~:intercept-when*","~:command","~$cljs.core/constantly","~$lark.commands.registry/register!","~$cljs.core/fn","~:lark.commands/Pass","^13"]],"~:order",["^1@","^1?","^1A","^1B","^1>","^B","^13","^1<","^1=","^1D","^1C","^1F","^1G","^1E"]],"~:flags",["^ "],"~:js-deps",["^ "],"~:deps",["^F","^<"]]